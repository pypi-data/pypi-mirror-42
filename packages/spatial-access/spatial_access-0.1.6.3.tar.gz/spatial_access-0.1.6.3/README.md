

# spatial_access: Large scale Python spatial access toolkit

<table>
<tr>
  <td>Version</td>
  <td>
    0.1.6.3
  </td>
</tr>    
<tr>
  <td>Latest Release</td>
  <td>
    <a href="https://travis-ci.org/GeoDaCenter/spatial_access">
    <img src="https://travis-ci.org/GeoDaCenter/spatial_access.svg?branch=master" alt="travis build status" />
  </td>
</tr>
<tr>
  <td>Development Build</td>
  <td>
    <a href="https://travis-ci.org/GeoDaCenter/spatial_access">
    <img src="https://travis-ci.org/GeoDaCenter/spatial_access.svg?branch=0.1.7" alt="travis build status" 
    </td>
</tr>
<tr>
  <td>Supported Operating Systems</td>
  <td>
       Linux, macOS
  </td>
</tr>
</table>


# Components of spatial_access :
----
1. p2p - a package for computing transit matrices for very large data sets
2. ScoreModel - a tool to manage the underlying data for geospatial models
3. CommunityAnalytics - Contains two models for studying urban accessibility to nonprofit services: HSSAModel and PCSpendModel

To use this service as a ReST API, see: https://github.com/GeoDaCenter/spatial_access_api 

If you are a Windows user, instructions for installing Ubuntu on a virtual machine are at the bottom of the Readme.


Installation 
----
1. `brew install spatialindex` (mac) or `sudo apt-get install libspatialindex-dev` (ubuntu)
2. `pip3 install spatial_access`


### Usage

See the iPython notebooks in docs/ for example usage.

### Technical Overview

The operation of P2P can be broken down into 6 steps:

1. Determining the bounding box:

First, we extract the extreme value of latitude/longitude from the source table and increase the borders of the bounding box by 'epsilon'. This is done avoid cutting off edges leading to data points near the boundary of the bounding box. Any points from the destination table outside the bounding box are dropped.

3. Download OSM network:

Using the previously determined bounding box, I then generate a query and download the appropriate network type from OSM, which consists of nodes and edges with a distance value. This is the only point any metadata (two coordinate pairs) related to the source data leaves the local system. 

3. Costing model:

The costing model has two components: an edge traversal speed and a node penalty. If the network type is 'walk', a walk speed of 5 km/h is used with no node penalty. If the network type is 'bike', a walk speed of 15 km/h is used with no node penalty. If the network type is driving, the edge traversal speed is drawn from a table of speed limits that must be supplied separately (and a default speed limit of 40 km/h for edges that cannot be matched), and the node penaty is 0 seconds. The network is directed, meaning that one way streets are respected and A->B and B->A can have different edge traversal speeds. The sparse network generated by this step is written to file.

4. Nearest Neighbor:

P2P uses a k-d tree to match each point in the source and destination data to its nearest neighbor node in the OSM network, and then finds the Vincenty distance between the two points.

5. Dijkstra's Algorithm:

P2P uses an adjacency list representation for Dijkstra's algorithm to find the shortest path for every node to every other node in the underlying OSM network, but it can skip doing any processing for nodes that do not have an attached source data point. The advantage of this approach is that it scales to essentially any size dataset; as opposed to the adjacency matrix representation (which can easily exceed the memory of many systems for reasonably large datasets) P2P never loads the entire network into memory at one time, meaning the memory footprint is relatively small. This also means the multithreaded performance of P2P greatly outperforms the singlethreaded performance. 

6. Compute Final Impedence:

For every point in the source dataset to every point in the destination dataset, the base impedence is the cost found using Dijstra. To the base value we add the 'last mile' inferred impedence from the source and destination points to their respective nearest nodes, determined by the Euclidean distance and a constant traversal speed. The 'last mile' is figurative; in the City of Chicago, for instance, 75 percent of block centroids were within 100 meters of the nearest OSM node and 95 percent of block centroids were within 200 meters.


## Installing Ubuntu 18 LTS with dependencies from scratch (recommended for Windows users)

1. Follow the instructions at this link: https://linus.nci.nih.gov/bdge/installUbuntu.html to set up a virtual machine
2. `sudo apt-get install git`
3. `git clone https://github.com/GeoDaCenter/spatial_access.git`
4. `sudo apt-get update`
5. `sudo add-apt-repository universe`
6. `sudo apt-get -y install python3-pip`
7. Continue with General Installation Instructions (above)

# Questions/Feedback?

lnoel@uchicago.edu
