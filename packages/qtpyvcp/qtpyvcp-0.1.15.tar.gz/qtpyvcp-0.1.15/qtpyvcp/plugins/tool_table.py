"""Tool Table data plugin.

Exposes all the info available in the tool table. Watches the
tool table file for changes and re-loads as needed.
"""

import os
from itertools import takewhile
from datetime import datetime

import linuxcnc

from qtpy.QtCore import QFileSystemWatcher, QTimer

import qtpyvcp
from qtpyvcp.utilities.info import Info
from qtpyvcp.utilities.logger import getLogger
from qtpyvcp.plugins import QtPyVCPDataPlugin, QtPyVCPDataChannel, getPlugin

CMD = linuxcnc.command()
LOG = getLogger(__name__)
STATUS = getPlugin('status')
INFO = Info()

IN_DESIGNER = os.getenv('DESIGNER', False)


def merge(a, b):
    """Shallow merge two dictionaries"""
    r = a.copy()
    r.update(b)
    return r


DEFAULT_TOOL = {
    'A': 0.0,
    'B': 0.0,
    'C': 0.0,
    'D': 0.0,
    'I': 0.0,
    'J': 0.0,
    'P': -1,
    'Q':  0,
    'T': -1,
    'U': 0.0,
    'V': 0.0,
    'W': 0.0,
    'X': 0.0,
    'Y': 0.0,
    'Z': 0.0,
    'R': '',
}

NO_TOOL = merge(DEFAULT_TOOL, {'T': 0, 'R': 'No Tool Loaded'})

FILE_HEADER = """
LinuxCNC Tool Table
-------------------

(QtPyVCP will preserve any comments before this separator.)
---
Generated by: QtPyVCP ToolTable plugin ({version})
Generated on: {datetime:%x %I:%M:%S %p}

"""

COLUMN_LABELS = {
    'A': 'A Offset',
    'B': 'B Offset',
    'C': 'C Offset',
    'D': 'Diameter',
    'I': 'Fnt Ang',
    'J': 'Bak Ang',
    'P': 'Pocket',
    'Q': 'Orient',
    'R': 'Remark',
    'T': 'Tool',
    'U': 'U Offset',
    'V': 'V Offset',
    'W': 'W Offset',
    'X': 'X Offset',
    'Y': 'Y Offset',
    'Z': 'Z Offset',
}

def makeLorumIpsumToolTable():
    return {i: merge(DEFAULT_TOOL,
                     {'T': i, 'P': i, 'R': 'Lorum Ipsum ' + str(i)})
            for i in range(10)}

class CurrentTool(QtPyVCPDataChannel):
    """Current tool data channel.
    """

    def __init__(self):
        super(CurrentTool, self).__init__()

        self._value = NO_TOOL

    @property
    def value(self):
        return self._value

    @property
    def number(self):
        return self._value['T']

    @property
    def pocket(self):
        return self._value['P']

    @property
    def diameter(self):
        return self._value['D']

    @property
    def x_offset(self):
        return self._value['X']

    @property
    def y_offset(self):
        return self._value['Y']

    @property
    def z_offset(self):
        return self._value['Z']

    @property
    def a_offset(self):
        return self._value['A']

    @property
    def b_offset(self):
        return self._value['B']

    @property
    def c_offset(self):
        return self._value['C']

    @property
    def u_offset(self):
        return self._value['U']

    @property
    def v_offset(self):
        return self._value['V']

    @property
    def w_offset(self):
        return self._value['W']

    @property
    def front_angle(self):
        return self._value['I']

    @property
    def back_angle(self):
        return self._value['J']

    @property
    def orientation(self):
        return self._value['Q']

    @property
    def comment(self):
        return self._value['R']

    def _update(self, value):
        self._value = value
        self.valueChanged.emit(value)


class ToolTable(QtPyVCPDataPlugin):

    protocol = 'tooltable'

    # data channels
    current_tool = CurrentTool()

    TOOL_TABLE = {}
    DEFAULT_TOOL = DEFAULT_TOOL
    COLUMN_LABELS = COLUMN_LABELS

    def __init__(self, columns='TPXYZDR', file_header_template=FILE_HEADER):
        super(ToolTable, self).__init__()

        self.fs_watcher = None
        self.orig_header_lines = []
        self.file_header_template = file_header_template or ''

        self.columns = self.validateColumns(columns) or [c for c in 'TPXYZDR']

        self.tool_table_file = INFO.getToolTableFile()
        if not os.path.exists(self.tool_table_file):
            return

        if self.TOOL_TABLE == {}:
            self.loadToolTable()

        self.current_tool._update(self.TOOL_TABLE[STATUS.tool_in_spindle.value])

        # update signals
        STATUS.tool_in_spindle.onValueChanged(self.onToolChanged)

    def initialise(self):
        self.fs_watcher = QFileSystemWatcher()
        self.fs_watcher.addPath(self.tool_table_file)
        self.fs_watcher.fileChanged.connect(self.onToolTableFileChanged)

    @staticmethod
    def validateColumns(columns):
        """Validate display column specification.

        The user can specify columns in multiple ways, method is used to make
        sure that that data is validated and converted to a consistent format.

        Args:
            columns (str | list) : A string or list of the column IDs
                that should be shown in the tooltable.

        Returns:
            None if not valid, else a list of uppercase column IDs.
        """
        if not isinstance(columns, (basestring, list, tuple)):
            return

        return [col for col in [col.strip().upper() for col in columns]
                if col in 'TPXYZABCUVWDIJQR' and not col == '']

    def newTool(self, tnum=None):
        """Get a dict of default tool values for a new tool."""
        if tnum is None:
            tnum = len(self.TOOL_TABLE)
        new_tool = DEFAULT_TOOL.copy()
        new_tool.update({'T': tnum, 'P': tnum, 'R': 'New Tool'})
        return new_tool

    def onToolTableFileChanged(self, path):
        LOG.debug('Tool Table file changed: {}'.format(path))
        # ToolEdit deletes the file and then rewrites it, so wait
        # a bit to ensure the new data has been writen out.
        QTimer.singleShot(50, self.reloadToolTable)

    def onToolChanged(self, tool_num):
        self.current_tool._update(self.TOOL_TABLE[tool_num])

    def reloadToolTable(self):
        # rewatch the file if it stop being watched because it was deleted
        if self.tool_table_file not in self.fs_watcher.files():
            self.fs_watcher.addPath(self.tool_table_file)

        # reload with the new data
        self.loadToolTable()

    def iterTools(self, tool_table=None, columns=None):
        tool_table = tool_table or self.TOOL_TABLE
        columns = self.validateColumns(columns) or self.columns
        for tool in sorted(tool_table.iterkeys()):
            tool_data = tool_table[tool]
            yield [tool_data[key] for key in columns]

    def loadToolTable(self, tool_file=None):

        if tool_file is None:
            tool_file = self.tool_table_file

        if not os.path.exists(tool_file):
            if IN_DESIGNER:
                return makeLorumIpsumToolTable()
            LOG.critical("Tool table file does not exist: {}".format(tool_file))
            return {}

        with open(tool_file, 'r') as fh:
            lines = [line.strip() for line in fh.readlines()]

        # find opening colon, and get header data so it can be restored
        for rlnum, line in enumerate(reversed(lines)):
            if line.startswith(';'):
                lnum = len(lines) - rlnum
                raw_header = lines[:lnum]
                lines = lines[lnum:]

                self.orig_header_lines = list(takewhile(lambda l:
                                        not l.strip() == '---' and
                                        not l.startswith(';Tool'), raw_header))
                break

        table = {0: NO_TOOL,}
        for line in lines:

            data, sep, comment = line.partition(';')

            tool = DEFAULT_TOOL.copy()
            for item in data.split():
                descriptor = item[0]
                if descriptor in 'TPXYZABCUVWDIJQR':
                    value = item.lstrip(descriptor)
                    if descriptor in ('T', 'P', 'Q'):
                        try:
                            tool[descriptor] = int(value)
                        except:
                            LOG.error('Error converting value to int: {}'.format(value))
                            break
                    else:
                        try:
                            tool[descriptor] = float(value)
                        except:
                            LOG.error('Error converting value to float: {}'.format(value))
                            break

            tool['R'] = comment.strip()

            tnum = tool['T']
            if tnum == -1:
                continue

            # add the tool to the table
            table[tnum] = tool

        # update tooltable
        self.__class__.TOOL_TABLE = table

        self.current_tool._update(self.TOOL_TABLE[STATUS.tool_in_spindle.value])

        # import json
        # print json.dumps(table, sort_keys=True, indent=4)

        return table.copy()

    def saveToolTable(self, tool_table, columns=None, tool_file=None):
        """Write tooltable data to file.

        Args:
            tool_table (dict) : Dictionary of dictionaries containing
                the tool data to write to the file.
            columns (str | list) : A list of data columns to write.
                If `None` will use the value of ``self.columns``.
            tool_file (str) : Path to write the tooltable too.
                Defaults to ``self.tool_table_file``.
        """

        columns = self.validateColumns(columns) or self.columns

        if tool_file is None:
            tool_file = self.tool_table_file

        lines = []

        # restore file header
        try:
            header_lines = self.file_header_template.format(
                                version=qtpyvcp.__version__,
                                datetime=datetime.now()).lstrip().splitlines()
            header_lines.append('') # extra new line before table header
        except:
            header_lines = []

        if self.orig_header_lines:
            try:
                self.orig_header_lines.extend(header_lines[header_lines.index('---'):])
                header_lines = self.orig_header_lines
            except ValueError:
                header_lines = self.orig_header_lines

        lines.extend(header_lines)

        # create the table header
        items = []
        for col in columns:
            if col == 'R':
                continue
            w = (6 if col in 'TPQ' else 8) - 1 if col == self.columns[0] else 0
            items.append('{:<{w}}'.format(COLUMN_LABELS[col], w=w))

        items.append('Remark')
        lines.append(';' + ' '.join(items))

        # add the tools
        for tool_num in sorted(tool_table.iterkeys())[1:]:
            items = []
            tool_data = tool_table[tool_num]
            for col in columns:
                if col == 'R':
                    continue
                items.append('{col}{val:<{w}}'
                             .format(col=col,
                                     val=tool_data[col],
                                     w=6 if col in 'TPQ' else 8))

            comment = tool_data.get('R', '')
            if comment is not '':
                items.append('; ' + comment)

            lines.append(''.join(items))

        # for line in lines:
        #     print line

        # write to file
        with open(tool_file, 'w') as fh:
            fh.write('\n'.join(lines))
            fh.flush()
            os.fsync(fh.fileno())

        CMD.load_tool_table()
