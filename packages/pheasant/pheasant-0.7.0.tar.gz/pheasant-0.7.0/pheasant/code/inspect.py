from typing import Generator

import nbformat

from pheasant.jupyter.renderer import run_and_render
from pheasant.markdown.splitter import escaped_splitter_join
from pheasant.number import config as config_number

from .config import config


def convert(source: str) -> str:
    source = ''.join(render(source))
    return source


def render(source: str) -> Generator[str, None, None]:
    pattern_escape = r'(```(.*?)```)|(~~~(.*?)~~~)'
    pattern_code = config['code_pattern']

    splitter = escaped_splitter_join(pattern_code, pattern_escape, source)
    for splitted in splitter:
        if isinstance(splitted, str):
            yield splitted
        else:
            language, reference = splitted.group(1, 2)
            if language == 'python':
                yield inspect(language, reference)
            else:
                yield splitted.group()


def inspect(language: str, reference: str,
            func='inspect.getsourcelines') -> str:
    """Inspect source code."""
    name, *options = reference.split(' ')  # `Options` is not implemented.
    name, *line_range = name.split(':')  # `line_range` is not implemented.

    cell = nbformat.v4.new_code_cell(f'{func}({name})')
    return run_and_render(cell, lambda cell: inspect_render(cell, language))


def inspect_render(cell, language: str) -> str:
    """Convert a cell generated by inspection into markdown."""
    begin = config_number['begin_pattern']
    end = config_number['end_pattern']
    for output in cell['outputs']:
        if 'data' in output and 'text/plain' in output['data']:
            lines, lineno = eval(output['data']['text/plain'])
            source = ''.join(lines)
            cls = '.pheasant-markdown .pheasant-code'
            return f'{begin}\n```{language} {cls}\n{source}```\n{end}\n'
    return ''
