from __future__ import absolute_import
import aether as ae
from aether.sky_utils import sky_utils
from api.base.PostMethodResourceBase import PostMethodResourceBase
from aether.proto.api_pb2 import SpacetimeBuilder, BytesTransmission, HttpResponse
from flask import request, send_from_directory
from aether_shared.utilities.user_api_utils import user_api_utils
from aether_shared.utilities.geometry_utils import geometry_utils
from flask_restful import reqparse
from flask import current_app

from api.gis.geotiff_transforms_handler import geotiff_transforms_handler
from utilities.sampling import sampling
from utilities.polygon_utils import polygon_utils
from utilities.tiler_utils import tiler_utils
from aether_shared.utilities.api_utils import api_utils
from PIL import Image

import numpy as np
import rasterio
import json
import io
import os
import copy
import tempfile

import logging
from six.moves import range
logger = logging.getLogger(__name__)

############################################################################################################
#
# The DynamicTilerResource is a two-step passive service for generating PNG (or TIF) tiles across a region.
# The service receives a window bounds (such as those generated by Google Maps), and locates the scene at
# the centroid of the bounds. The scene is then tiled according to UTM x/y/z coordinates as 256x256 pixel
# images. These images are then cached on a stack on the Resource.
#
# A second service, RetrieveNextNTiles, issues back the bottom of the N tiles on the stack. This service
# also communicates back the number of tiles still on the stack.
#
# The creation of tiles by QueueCentroidScene is generally bandwidth limited for the download of the scenes.
# Because of this, the transition to COG will make this arrangement very fast. In the meantime, this means
# the stack (cache) of tiles is not updated with every tile on the stack, creating a small latency to start.
#
#
# Note: This Flask cache uses pickle, which cannot handle the File objects. The NamedTemporary files will
# self-delete if only the name is cached and self-delete is set to True. This creates a memory leak risk
# with any Flask cache, for which I do not yet have a solution. (Simply wrapping the app cache functionality
# will suffice.)
############################################################################################################

# Add merge of two pngs. Register with original scene bounds or centroi.

_bit_depth_scale_factor = dict(
    uint16=2**16,
    uint8=2**8,
    float32=2**32,
)

class DynamicTilerResource(PostMethodResourceBase):

    _post_methods = dict(
        RetrieveNextNTiles="RetrieveNextNTiles",
        QueueCentroidScene="QueueCentroidScene",
    )

    def __init__(self, global_objects):
        self.tile_size_px = 256

        self.not_on_client_side = api_utils.simple_cache_get(current_app, 'not_on_client_side', [])
        self.png_tile_cache = api_utils.simple_cache_get(current_app, 'png_tile_cache', {})
        self.png_layer_cache = api_utils.simple_cache_get(current_app, 'png_layer_cache', {})

        self._global_objects = global_objects
        super(DynamicTilerResource, self).__init__(global_objects, logger)

    def RetrieveNextTile(self, request):
        parser = reqparse.RequestParser(bundle_errors=True)
        parser.add_argument('uuid', type=str, required=True, location='json')
        parser.add_argument('bounds', type=str, required=True, location='json')
        parser.add_argument('render_or_data', type=str, required=True, location='json')
        args = parser.parse_args()


        ae.GlobalConfig.set_user(args["uuid"])
        ae.GlobalConfig._switch_service_locality(to_local=True)
        ae.GlobalConfig.hostport = "127.0.0.1:5003"

        response = dict(
            data="",
            bounds="",
            remaining=0
        )

        self.not_on_client_side = api_utils.simple_cache_get(current_app, 'not_on_client_side', [])
        self.png_tile_cache = api_utils.simple_cache_get(current_app, 'png_tile_cache', {})

        p = None
        while p is None and len(self.not_on_client_side) != 0:
            p = self.not_on_client_side.pop(0)
            if p not in self.png_tile_cache:
                logger.warn("Tile listed as processed (not on client side), yet not in cache: {}".format(p))

        api_utils.simple_cache_set(current_app, 'not_on_client_side', self.not_on_client_side)

        if p is None:
            return response

        png_file = self.png_tile_cache[p]
        with open(png_file.name, "rb") as f:
            data = sky_utils.serialize_for_url(f.read())

        response["data"] = data
        response["remaining"] = len(self.not_on_client_side)

        return response


    def QueueCentroidScene(self, request):
        parser = reqparse.RequestParser(bundle_errors=True)
        parser.add_argument('uuid', type=str, required=True, location='json')
        parser.add_argument('bounds', type=str, required=True, location='json')
        parser.add_argument('zoom', type=int, required=True, location='json')
        parser.add_argument('resource_name', type=str, required=True, location='json')
        parser.add_argument('bands_to_render', type=str, required=True, location='json')
        parser.add_argument('additional_bands_to_load', type=str, required=True, location='json')
        args = parser.parse_args()

        try:
            uuid = args["uuid"]
            bounds = json.loads(args["bounds"])
            zoom = args["zoom"]
            resource_name = args["resource_name"]
            bands_to_render = json.loads(args["bands_to_render"])
            additional_bands_to_load = json.loads(args["additional_bands_to_load"])
            response = self.load_a_scene(uuid, bounds, zoom, resource_name, bands_to_render, additional_bands_to_load)
        except Exception:
            return api_utils.log_and_return_status("DynamicTilerResource {} failed.".format(request), 500, request, logger, exc_info=True)

        return api_utils.log_and_return_status(response, 200, request, logger)

    def load_a_scene(self, uuid, bounds, zoom, resource_name, bands_to_render, additional_bands_to_load):
        ae.GlobalConfig.set_user(uuid)
        ae.GlobalConfig._switch_service_locality(to_local=True)
        ae.GlobalConfig.hostport = "127.0.0.1:5003"

        centroid = polygon_utils.centroid_of_bounds(bounds)

        self.requested_resource = resource_name
        self.centroid = centroid
        self.requested_bounds = bounds
        self.bands_to_render = bands_to_render
        self.additional_bands_to_load = additional_bands_to_load
        self.requested_bands = list(set(bands_to_render + additional_bands_to_load))

        logger.info("Centered around {} with bounds {}.".format(self.centroid, self.requested_bounds))
        logger.info("Requested bands: {} rendered, {} additional loaded, {} in all.".format(
            bands_to_render, additional_bands_to_load, self.requested_bands))

        bands_downloaded = self.requested_bands + ["QA"]

        resource_name = self.requested_resource
        query_parameters = dict(
            date_acquired=[ae.QueryParameter.Ordered.LAST],
            bands=bands_downloaded,
            spacecraft_id=["LANDSAT_8"]
        )

        epsilon = 0.0001
        b = [centroid[1] - epsilon, centroid[0] - epsilon, centroid[1] + epsilon, centroid[0] + epsilon]
        coordinates = polygon_utils.coordinates_from_bounds(b)
        polygon = ae.AEPolygon(coordinates)

        # To conserve space, this routine will compile the images band by band, storing as PNG for each.
        layer_cache = {}
        with ae.SkySession() as sky:
            spacetime_builder = \
                sky.Resource(resource_name).search(polygon, query_parameters)
            if len(spacetime_builder.timestamps) == 0:
                return dict(centroid=json.dumps(centroid), n_tiles_added=0)

            s = ae.Spacetime(spacetime_builder, sky)
            b0 = s.generate_mask(ts_i=0)
            b0 = np.expand_dims((b0 == 255), axis=-1)

            # Get the mask from the QA band.
            b_mask = bands_downloaded.index("QA")
            with rasterio.open(s.getSrcFilename(ts_i=0, b_i=b_mask)) as mask_src:
                with rasterio.open(s.get_reference_crs().name) as ref_src:
                    utm_bounds = ref_src.bounds
                    p = ae.AEPolygon().from_bounds(utm_bounds)
                    p = geometry_utils.transform_to_latlng(ref_src.meta["crs"], [p])
                    image_bounds = p[0].to_bounds()

                    # Tiles use the XYZ standard (first line creates xy, second line creates latlng into AEPolygons,
                    # third line creates pixels.)
                    xy_tiles = tiler_utils.bounds_to_xyz_tileset(image_bounds, zoom)
                    poly_tiles = [ae.AEPolygon(tiler_utils.tile_xyz_to_latlng_polygon_coordinates(t, zoom)) for t in xy_tiles]
                    utm_tiles = geometry_utils.transform_latlng_to_pixels(ref_src.meta["crs"], poly_tiles)

                    n_tiles_added = 0
                    for band in self.bands_to_render:
                        b_i = bands_downloaded.index(band)
                        with rasterio.open(s.getSrcFilename(ts_i=0, b_i=b_i)) as src_i:
                            for tile_i in range(len(utm_tiles)):
                                xyz_str = "{resource}/{zoom}/{x}/{y}/".format(
                                    resource=resource_name, zoom=zoom, x=xy_tiles[tile_i][0], y=xy_tiles[tile_i][1],
                                ).lower()
                                xyz_band_str = "{resource}/{zoom}/{x}/{y}/{band}/".format(
                                    resource=resource_name, zoom=zoom, x=xy_tiles[tile_i][0], y=xy_tiles[tile_i][1],
                                    band=band,
                                ).lower()
                                self.png_tile_cache = api_utils.simple_cache_get(current_app, 'png_tile_cache', {})
                                self.png_layer_cache = api_utils.simple_cache_get(current_app, 'png_layer_cache', {})

                                if xyz_str in self.png_tile_cache or xyz_band_str in self.png_layer_cache:
                                    continue

                                crop_data, _, crop_meta = \
                                    geotiff_transforms_handler.geotiff_window_read(src_i, utm_tiles[tile_i], make_mask=False)
                                crop_mask, _, _ = \
                                    geotiff_transforms_handler.geotiff_window_read(mask_src, utm_tiles[tile_i], make_mask=False)

                                crop_polygon = geotiff_transforms_handler.map_crop_into_latlng_bounds(
                                    src_i, crop_meta["transform"], utm_tiles[tile_i])

                                data_type = crop_meta["dtype"]
                                scale_factor = _bit_depth_scale_factor[data_type]
                                crop_data = np.squeeze(np.uint8(crop_data * 255. / scale_factor), axis=2)
                                crop_mask = np.squeeze(np.uint8((crop_mask!=1) * 255.), axis=2)

                                mask = Image.fromarray(crop_mask, mode="L")
                                image = Image.fromarray(crop_data, mode="L")
                                image.putalpha(mask)
                                # image.show()

                                temporary_file = tempfile.NamedTemporaryFile(delete=False, suffix=".PNG")
                                image.save(temporary_file.name)

                                logger.info("Adding to cache: {} the filename {}".format(xyz_band_str, temporary_file.name))
                                if xyz_band_str not in self.png_layer_cache:
                                    self.png_layer_cache[xyz_band_str] = dict(is_complete=False, parts=[])
                                self.png_layer_cache[xyz_band_str]["parts"].append(dict(
                                    polygon_bounds=crop_polygon.to_bounds(),
                                    png_filename=temporary_file.name,
                                ))
                                api_utils.simple_cache_set(current_app, 'png_layer_cache', self.png_layer_cache)

            for tile_i in range(len(utm_tiles)):
                xyz_str = "{resource}/{zoom}/{x}/{y}/".format(
                    resource=resource_name, zoom=zoom, x=xy_tiles[tile_i][0], y=xy_tiles[tile_i][1],
                ).lower()

                self.png_layer_cache = api_utils.simple_cache_get(current_app, 'png_layer_cache', {})
                if xyz_str in self.png_tile_cache:
                    continue

                potential_thread_error_occurred = False
                tile_numpy = []
                for band in self.bands_to_render:
                    xyz_band_str = "{resource}/{zoom}/{x}/{y}/{band}/".format(
                        resource=resource_name, zoom=zoom, x=xy_tiles[tile_i][0], y=xy_tiles[tile_i][1],
                        band=band,
                    ).lower()

                    self.png_layer_cache = api_utils.simple_cache_get(current_app, 'png_layer_cache', {})
                    if xyz_band_str not in self.png_layer_cache:
                        potential_thread_error_occurred = True
                        break

                    tile_numpy.append(np.array(Image.open(self.png_layer_cache[xyz_band_str])))

                if potential_thread_error_occurred or len(tile_numpy) == 0:
                    continue

                foreground = np.transpose(np.stack([t[:,:,0] for t in tile_numpy], axis=0), axes=[1,2,0])
                mask = np.uint8(255 * np.bitwise_or(*([t[:,:,1]==255 for t in tile_numpy])))
                image = Image.fromarray(foreground, mode="RGB")
                mask = Image.fromarray(mask, mode="L")
                image.putalpha(mask)
                image.show()

                temporary_file = tempfile.NamedTemporaryFile(delete=False, suffix=".PNG")
                image.save(temporary_file.name)

                logger.info("Adding to cache: {} the filename {}".format(xyz_str, temporary_file.name))
                self.png_tile_cache[xyz_str] = temporary_file.name
                api_utils.simple_cache_set(current_app, 'png_tile_cache', self.png_tile_cache)

                self.not_on_client_side.append(xyz_str)
                api_utils.simple_cache_set(current_app, 'not_on_client_side', self.not_on_client_side)

                n_tiles_added += 1

        return dict(centroid=json.dumps(centroid),
                    n_tiles_added=n_tiles_added,
                    n_not_on_client_side=len(self.not_on_client_side))
