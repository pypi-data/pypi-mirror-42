# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from __future__ import absolute_import, print_function, division
import struct



from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_softfloat')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_softfloat')
    _softfloat = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_softfloat', [dirname(__file__)])
        except ImportError:
            import _softfloat
            return _softfloat
        try:
            _mod = imp.load_module('_softfloat', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _softfloat = swig_import_helper()
    del swig_import_helper
else:
    import _softfloat
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

softfloat_types_h = _softfloat.softfloat_types_h
class float16_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, float16_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, float16_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["v"] = _softfloat.float16_t_v_set
    __swig_getmethods__["v"] = _softfloat.float16_t_v_get
    if _newclass:
        v = _swig_property(_softfloat.float16_t_v_get, _softfloat.float16_t_v_set)

    def fromBits(self, bits):
        return _softfloat.float16_t_fromBits(self, bits)

    def toBits(self):
        return _softfloat.float16_t_toBits(self)

    def toHex(self):
        return _softfloat.float16_t_toHex(self)

    def toInt(self):
        return _softfloat.float16_t_toInt(self)

    def __rshift__(self, n):
        return _softfloat.float16_t___rshift__(self, n)

    def __lshift__(self, n):
        return _softfloat.float16_t___lshift__(self, n)

    def __invert__(self):
        return _softfloat.float16_t___invert__(self)

    def __neg__(self):
        return _softfloat.float16_t___neg__(self)

    def __abs__(self):
        return _softfloat.float16_t___abs__(self)

    def __and__(self, other):
        return _softfloat.float16_t___and__(self, other)

    def __xor__(self, other):
        return _softfloat.float16_t___xor__(self, other)

    def __or__(self, other):
        return _softfloat.float16_t___or__(self, other)

    def __repr__(self):
        a = float(_softfloat.convertF16ToDouble(self))
        return str(a)
    def __str__(self):
        a = float(_softfloat.convertF16ToDouble(self))
        return str(a)


    def __init__(self):
        this = _softfloat.new_float16_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _softfloat.delete_float16_t
    __del__ = lambda self: None
float16_t_swigregister = _softfloat.float16_t_swigregister
float16_t_swigregister(float16_t)

class float32_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, float32_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, float32_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["v"] = _softfloat.float32_t_v_set
    __swig_getmethods__["v"] = _softfloat.float32_t_v_get
    if _newclass:
        v = _swig_property(_softfloat.float32_t_v_get, _softfloat.float32_t_v_set)

    def fromBits(self, bits):
        return _softfloat.float32_t_fromBits(self, bits)

    def toBits(self):
        return _softfloat.float32_t_toBits(self)

    def toHex(self):
        return _softfloat.float32_t_toHex(self)

    def toInt(self):
        return _softfloat.float32_t_toInt(self)

    def __rshift__(self, n):
        return _softfloat.float32_t___rshift__(self, n)

    def __lshift__(self, n):
        return _softfloat.float32_t___lshift__(self, n)

    def __invert__(self):
        return _softfloat.float32_t___invert__(self)

    def __neg__(self):
        return _softfloat.float32_t___neg__(self)

    def __abs__(self):
        return _softfloat.float32_t___abs__(self)

    def __and__(self, other):
        return _softfloat.float32_t___and__(self, other)

    def __xor__(self, other):
        return _softfloat.float32_t___xor__(self, other)

    def __or__(self, other):
        return _softfloat.float32_t___or__(self, other)

    def __repr__(self):
        a = float(_softfloat.convertF32ToDouble(self))
        return str(a)
    def __str__(self):
        a = float(_softfloat.convertF32ToDouble(self))
        return str(a)


    def __init__(self):
        this = _softfloat.new_float32_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _softfloat.delete_float32_t
    __del__ = lambda self: None
float32_t_swigregister = _softfloat.float32_t_swigregister
float32_t_swigregister(float32_t)

class float64_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, float64_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, float64_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["v"] = _softfloat.float64_t_v_set
    __swig_getmethods__["v"] = _softfloat.float64_t_v_get
    if _newclass:
        v = _swig_property(_softfloat.float64_t_v_get, _softfloat.float64_t_v_set)

    def init(self):
        return _softfloat.float64_t_init(self)

    def fromBits(self, bits):
        return _softfloat.float64_t_fromBits(self, bits)

    def toBits(self):
        return _softfloat.float64_t_toBits(self)

    def toHex(self):
        return _softfloat.float64_t_toHex(self)

    def toInt(self):
        return _softfloat.float64_t_toInt(self)

    def __rshift__(self, n):
        return _softfloat.float64_t___rshift__(self, n)

    def __lshift__(self, n):
        return _softfloat.float64_t___lshift__(self, n)

    def __invert__(self):
        return _softfloat.float64_t___invert__(self)

    def __neg__(self):
        return _softfloat.float64_t___neg__(self)

    def __abs__(self):
        return _softfloat.float64_t___abs__(self)

    def __and__(self, other):
        return _softfloat.float64_t___and__(self, other)

    def __xor__(self, other):
        return _softfloat.float64_t___xor__(self, other)

    def __or__(self, other):
        return _softfloat.float64_t___or__(self, other)

    def __repr__(self):
        a = float(struct.unpack('>d', struct.pack('>Q', self.v))[0])
        return str(a)
    def __str__(self):
        a = float(struct.unpack('>d', struct.pack('>Q', self.v))[0])
        return str(a)


    def __init__(self):
        this = _softfloat.new_float64_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _softfloat.delete_float64_t
    __del__ = lambda self: None
float64_t_swigregister = _softfloat.float64_t_swigregister
float64_t_swigregister(float64_t)

class float128_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, float128_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, float128_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["v"] = _softfloat.float128_t_v_set
    __swig_getmethods__["v"] = _softfloat.float128_t_v_get
    if _newclass:
        v = _swig_property(_softfloat.float128_t_v_get, _softfloat.float128_t_v_set)

    def __init__(self):
        this = _softfloat.new_float128_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _softfloat.delete_float128_t
    __del__ = lambda self: None
float128_t_swigregister = _softfloat.float128_t_swigregister
float128_t_swigregister(float128_t)

class extFloat80M(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, extFloat80M, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, extFloat80M, name)
    __repr__ = _swig_repr
    __swig_setmethods__["signExp"] = _softfloat.extFloat80M_signExp_set
    __swig_getmethods__["signExp"] = _softfloat.extFloat80M_signExp_get
    if _newclass:
        signExp = _swig_property(_softfloat.extFloat80M_signExp_get, _softfloat.extFloat80M_signExp_set)
    __swig_setmethods__["signif"] = _softfloat.extFloat80M_signif_set
    __swig_getmethods__["signif"] = _softfloat.extFloat80M_signif_get
    if _newclass:
        signif = _swig_property(_softfloat.extFloat80M_signif_get, _softfloat.extFloat80M_signif_set)

    def __init__(self):
        this = _softfloat.new_extFloat80M()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _softfloat.delete_extFloat80M
    __del__ = lambda self: None
extFloat80M_swigregister = _softfloat.extFloat80M_swigregister
extFloat80M_swigregister(extFloat80M)

softfloat_h = _softfloat.softfloat_h
softfloat_tininess_beforeRounding = _softfloat.softfloat_tininess_beforeRounding
softfloat_tininess_afterRounding = _softfloat.softfloat_tininess_afterRounding
softfloat_round_near_even = _softfloat.softfloat_round_near_even
softfloat_round_minMag = _softfloat.softfloat_round_minMag
softfloat_round_min = _softfloat.softfloat_round_min
softfloat_round_max = _softfloat.softfloat_round_max
softfloat_round_near_maxMag = _softfloat.softfloat_round_near_maxMag
softfloat_round_odd = _softfloat.softfloat_round_odd
softfloat_flag_inexact = _softfloat.softfloat_flag_inexact
softfloat_flag_underflow = _softfloat.softfloat_flag_underflow
softfloat_flag_overflow = _softfloat.softfloat_flag_overflow
softfloat_flag_infinite = _softfloat.softfloat_flag_infinite
softfloat_flag_invalid = _softfloat.softfloat_flag_invalid

def softfloat_raiseFlags(arg1):
    return _softfloat.softfloat_raiseFlags(arg1)
softfloat_raiseFlags = _softfloat.softfloat_raiseFlags

def ui32_to_f16(arg1):
    return _softfloat.ui32_to_f16(arg1)
ui32_to_f16 = _softfloat.ui32_to_f16

def ui32_to_f32(arg1):
    return _softfloat.ui32_to_f32(arg1)
ui32_to_f32 = _softfloat.ui32_to_f32

def ui32_to_f64(arg1):
    return _softfloat.ui32_to_f64(arg1)
ui32_to_f64 = _softfloat.ui32_to_f64

def ui32_to_extF80M(arg1, arg2):
    return _softfloat.ui32_to_extF80M(arg1, arg2)
ui32_to_extF80M = _softfloat.ui32_to_extF80M

def ui32_to_f128M(arg1, arg2):
    return _softfloat.ui32_to_f128M(arg1, arg2)
ui32_to_f128M = _softfloat.ui32_to_f128M

def ui64_to_f16(arg1):
    return _softfloat.ui64_to_f16(arg1)
ui64_to_f16 = _softfloat.ui64_to_f16

def ui64_to_f32(arg1):
    return _softfloat.ui64_to_f32(arg1)
ui64_to_f32 = _softfloat.ui64_to_f32

def ui64_to_f64(arg1):
    return _softfloat.ui64_to_f64(arg1)
ui64_to_f64 = _softfloat.ui64_to_f64

def ui64_to_extF80M(arg1, arg2):
    return _softfloat.ui64_to_extF80M(arg1, arg2)
ui64_to_extF80M = _softfloat.ui64_to_extF80M

def ui64_to_f128M(arg1, arg2):
    return _softfloat.ui64_to_f128M(arg1, arg2)
ui64_to_f128M = _softfloat.ui64_to_f128M

def i32_to_f16(arg1):
    return _softfloat.i32_to_f16(arg1)
i32_to_f16 = _softfloat.i32_to_f16

def i32_to_f32(arg1):
    return _softfloat.i32_to_f32(arg1)
i32_to_f32 = _softfloat.i32_to_f32

def i32_to_f64(arg1):
    return _softfloat.i32_to_f64(arg1)
i32_to_f64 = _softfloat.i32_to_f64

def i32_to_extF80M(arg1, arg2):
    return _softfloat.i32_to_extF80M(arg1, arg2)
i32_to_extF80M = _softfloat.i32_to_extF80M

def i32_to_f128M(arg1, arg2):
    return _softfloat.i32_to_f128M(arg1, arg2)
i32_to_f128M = _softfloat.i32_to_f128M

def i64_to_f16(arg1):
    return _softfloat.i64_to_f16(arg1)
i64_to_f16 = _softfloat.i64_to_f16

def i64_to_f32(arg1):
    return _softfloat.i64_to_f32(arg1)
i64_to_f32 = _softfloat.i64_to_f32

def i64_to_f64(arg1):
    return _softfloat.i64_to_f64(arg1)
i64_to_f64 = _softfloat.i64_to_f64

def i64_to_extF80M(arg1, arg2):
    return _softfloat.i64_to_extF80M(arg1, arg2)
i64_to_extF80M = _softfloat.i64_to_extF80M

def i64_to_f128M(arg1, arg2):
    return _softfloat.i64_to_f128M(arg1, arg2)
i64_to_f128M = _softfloat.i64_to_f128M

def f16_to_ui32(arg1, arg2, arg3):
    return _softfloat.f16_to_ui32(arg1, arg2, arg3)
f16_to_ui32 = _softfloat.f16_to_ui32

def f16_to_ui64(arg1, arg2, arg3):
    return _softfloat.f16_to_ui64(arg1, arg2, arg3)
f16_to_ui64 = _softfloat.f16_to_ui64

def f16_to_i32(arg1, arg2, arg3):
    return _softfloat.f16_to_i32(arg1, arg2, arg3)
f16_to_i32 = _softfloat.f16_to_i32

def f16_to_i64(arg1, arg2, arg3):
    return _softfloat.f16_to_i64(arg1, arg2, arg3)
f16_to_i64 = _softfloat.f16_to_i64

def f16_to_ui32_r_minMag(arg1, arg2):
    return _softfloat.f16_to_ui32_r_minMag(arg1, arg2)
f16_to_ui32_r_minMag = _softfloat.f16_to_ui32_r_minMag

def f16_to_ui64_r_minMag(arg1, arg2):
    return _softfloat.f16_to_ui64_r_minMag(arg1, arg2)
f16_to_ui64_r_minMag = _softfloat.f16_to_ui64_r_minMag

def f16_to_i32_r_minMag(arg1, arg2):
    return _softfloat.f16_to_i32_r_minMag(arg1, arg2)
f16_to_i32_r_minMag = _softfloat.f16_to_i32_r_minMag

def f16_to_i64_r_minMag(arg1, arg2):
    return _softfloat.f16_to_i64_r_minMag(arg1, arg2)
f16_to_i64_r_minMag = _softfloat.f16_to_i64_r_minMag

def f16_to_f32(arg1):
    return _softfloat.f16_to_f32(arg1)
f16_to_f32 = _softfloat.f16_to_f32

def f16_to_f64(arg1):
    return _softfloat.f16_to_f64(arg1)
f16_to_f64 = _softfloat.f16_to_f64

def f16_to_extF80M(arg1, arg2):
    return _softfloat.f16_to_extF80M(arg1, arg2)
f16_to_extF80M = _softfloat.f16_to_extF80M

def f16_to_f128M(arg1, arg2):
    return _softfloat.f16_to_f128M(arg1, arg2)
f16_to_f128M = _softfloat.f16_to_f128M

def f16_roundToInt(arg1, arg2, arg3):
    return _softfloat.f16_roundToInt(arg1, arg2, arg3)
f16_roundToInt = _softfloat.f16_roundToInt

def f16_add(arg1, arg2):
    return _softfloat.f16_add(arg1, arg2)
f16_add = _softfloat.f16_add

def f16_sub(arg1, arg2):
    return _softfloat.f16_sub(arg1, arg2)
f16_sub = _softfloat.f16_sub

def f16_mul(arg1, arg2):
    return _softfloat.f16_mul(arg1, arg2)
f16_mul = _softfloat.f16_mul

def f16_mulAdd(arg1, arg2, arg3):
    return _softfloat.f16_mulAdd(arg1, arg2, arg3)
f16_mulAdd = _softfloat.f16_mulAdd

def f16_div(arg1, arg2):
    return _softfloat.f16_div(arg1, arg2)
f16_div = _softfloat.f16_div

def f16_rem(arg1, arg2):
    return _softfloat.f16_rem(arg1, arg2)
f16_rem = _softfloat.f16_rem

def f16_sqrt(arg1):
    return _softfloat.f16_sqrt(arg1)
f16_sqrt = _softfloat.f16_sqrt

def f16_eq(arg1, arg2):
    return _softfloat.f16_eq(arg1, arg2)
f16_eq = _softfloat.f16_eq

def f16_le(arg1, arg2):
    return _softfloat.f16_le(arg1, arg2)
f16_le = _softfloat.f16_le

def f16_lt(arg1, arg2):
    return _softfloat.f16_lt(arg1, arg2)
f16_lt = _softfloat.f16_lt

def f16_eq_signaling(arg1, arg2):
    return _softfloat.f16_eq_signaling(arg1, arg2)
f16_eq_signaling = _softfloat.f16_eq_signaling

def f16_le_quiet(arg1, arg2):
    return _softfloat.f16_le_quiet(arg1, arg2)
f16_le_quiet = _softfloat.f16_le_quiet

def f16_lt_quiet(arg1, arg2):
    return _softfloat.f16_lt_quiet(arg1, arg2)
f16_lt_quiet = _softfloat.f16_lt_quiet

def f16_isSignalingNaN(arg1):
    return _softfloat.f16_isSignalingNaN(arg1)
f16_isSignalingNaN = _softfloat.f16_isSignalingNaN

def f32_to_ui32(arg1, arg2, arg3):
    return _softfloat.f32_to_ui32(arg1, arg2, arg3)
f32_to_ui32 = _softfloat.f32_to_ui32

def f32_to_ui64(arg1, arg2, arg3):
    return _softfloat.f32_to_ui64(arg1, arg2, arg3)
f32_to_ui64 = _softfloat.f32_to_ui64

def f32_to_i32(arg1, arg2, arg3):
    return _softfloat.f32_to_i32(arg1, arg2, arg3)
f32_to_i32 = _softfloat.f32_to_i32

def f32_to_i64(arg1, arg2, arg3):
    return _softfloat.f32_to_i64(arg1, arg2, arg3)
f32_to_i64 = _softfloat.f32_to_i64

def f32_to_ui32_r_minMag(arg1, arg2):
    return _softfloat.f32_to_ui32_r_minMag(arg1, arg2)
f32_to_ui32_r_minMag = _softfloat.f32_to_ui32_r_minMag

def f32_to_ui64_r_minMag(arg1, arg2):
    return _softfloat.f32_to_ui64_r_minMag(arg1, arg2)
f32_to_ui64_r_minMag = _softfloat.f32_to_ui64_r_minMag

def f32_to_i32_r_minMag(arg1, arg2):
    return _softfloat.f32_to_i32_r_minMag(arg1, arg2)
f32_to_i32_r_minMag = _softfloat.f32_to_i32_r_minMag

def f32_to_i64_r_minMag(arg1, arg2):
    return _softfloat.f32_to_i64_r_minMag(arg1, arg2)
f32_to_i64_r_minMag = _softfloat.f32_to_i64_r_minMag

def f32_to_f16(arg1):
    return _softfloat.f32_to_f16(arg1)
f32_to_f16 = _softfloat.f32_to_f16

def f32_to_f64(arg1):
    return _softfloat.f32_to_f64(arg1)
f32_to_f64 = _softfloat.f32_to_f64

def f32_to_extF80M(arg1, arg2):
    return _softfloat.f32_to_extF80M(arg1, arg2)
f32_to_extF80M = _softfloat.f32_to_extF80M

def f32_to_f128M(arg1, arg2):
    return _softfloat.f32_to_f128M(arg1, arg2)
f32_to_f128M = _softfloat.f32_to_f128M

def f32_roundToInt(arg1, arg2, arg3):
    return _softfloat.f32_roundToInt(arg1, arg2, arg3)
f32_roundToInt = _softfloat.f32_roundToInt

def f32_add(arg1, arg2):
    return _softfloat.f32_add(arg1, arg2)
f32_add = _softfloat.f32_add

def f32_sub(arg1, arg2):
    return _softfloat.f32_sub(arg1, arg2)
f32_sub = _softfloat.f32_sub

def f32_mul(arg1, arg2):
    return _softfloat.f32_mul(arg1, arg2)
f32_mul = _softfloat.f32_mul

def f32_mulAdd(arg1, arg2, arg3):
    return _softfloat.f32_mulAdd(arg1, arg2, arg3)
f32_mulAdd = _softfloat.f32_mulAdd

def f32_div(arg1, arg2):
    return _softfloat.f32_div(arg1, arg2)
f32_div = _softfloat.f32_div

def f32_rem(arg1, arg2):
    return _softfloat.f32_rem(arg1, arg2)
f32_rem = _softfloat.f32_rem

def f32_sqrt(arg1):
    return _softfloat.f32_sqrt(arg1)
f32_sqrt = _softfloat.f32_sqrt

def f32_eq(arg1, arg2):
    return _softfloat.f32_eq(arg1, arg2)
f32_eq = _softfloat.f32_eq

def f32_le(arg1, arg2):
    return _softfloat.f32_le(arg1, arg2)
f32_le = _softfloat.f32_le

def f32_lt(arg1, arg2):
    return _softfloat.f32_lt(arg1, arg2)
f32_lt = _softfloat.f32_lt

def f32_eq_signaling(arg1, arg2):
    return _softfloat.f32_eq_signaling(arg1, arg2)
f32_eq_signaling = _softfloat.f32_eq_signaling

def f32_le_quiet(arg1, arg2):
    return _softfloat.f32_le_quiet(arg1, arg2)
f32_le_quiet = _softfloat.f32_le_quiet

def f32_lt_quiet(arg1, arg2):
    return _softfloat.f32_lt_quiet(arg1, arg2)
f32_lt_quiet = _softfloat.f32_lt_quiet

def f32_isSignalingNaN(arg1):
    return _softfloat.f32_isSignalingNaN(arg1)
f32_isSignalingNaN = _softfloat.f32_isSignalingNaN

def f64_to_ui32(arg1, arg2, arg3):
    return _softfloat.f64_to_ui32(arg1, arg2, arg3)
f64_to_ui32 = _softfloat.f64_to_ui32

def f64_to_ui64(arg1, arg2, arg3):
    return _softfloat.f64_to_ui64(arg1, arg2, arg3)
f64_to_ui64 = _softfloat.f64_to_ui64

def f64_to_i32(arg1, arg2, arg3):
    return _softfloat.f64_to_i32(arg1, arg2, arg3)
f64_to_i32 = _softfloat.f64_to_i32

def f64_to_i64(arg1, arg2, arg3):
    return _softfloat.f64_to_i64(arg1, arg2, arg3)
f64_to_i64 = _softfloat.f64_to_i64

def f64_to_ui32_r_minMag(arg1, arg2):
    return _softfloat.f64_to_ui32_r_minMag(arg1, arg2)
f64_to_ui32_r_minMag = _softfloat.f64_to_ui32_r_minMag

def f64_to_ui64_r_minMag(arg1, arg2):
    return _softfloat.f64_to_ui64_r_minMag(arg1, arg2)
f64_to_ui64_r_minMag = _softfloat.f64_to_ui64_r_minMag

def f64_to_i32_r_minMag(arg1, arg2):
    return _softfloat.f64_to_i32_r_minMag(arg1, arg2)
f64_to_i32_r_minMag = _softfloat.f64_to_i32_r_minMag

def f64_to_i64_r_minMag(arg1, arg2):
    return _softfloat.f64_to_i64_r_minMag(arg1, arg2)
f64_to_i64_r_minMag = _softfloat.f64_to_i64_r_minMag

def f64_to_f16(arg1):
    return _softfloat.f64_to_f16(arg1)
f64_to_f16 = _softfloat.f64_to_f16

def f64_to_f32(arg1):
    return _softfloat.f64_to_f32(arg1)
f64_to_f32 = _softfloat.f64_to_f32

def f64_to_extF80M(arg1, arg2):
    return _softfloat.f64_to_extF80M(arg1, arg2)
f64_to_extF80M = _softfloat.f64_to_extF80M

def f64_to_f128M(arg1, arg2):
    return _softfloat.f64_to_f128M(arg1, arg2)
f64_to_f128M = _softfloat.f64_to_f128M

def f64_roundToInt(arg1, arg2, arg3):
    return _softfloat.f64_roundToInt(arg1, arg2, arg3)
f64_roundToInt = _softfloat.f64_roundToInt

def f64_add(arg1, arg2):
    return _softfloat.f64_add(arg1, arg2)
f64_add = _softfloat.f64_add

def f64_sub(arg1, arg2):
    return _softfloat.f64_sub(arg1, arg2)
f64_sub = _softfloat.f64_sub

def f64_mul(arg1, arg2):
    return _softfloat.f64_mul(arg1, arg2)
f64_mul = _softfloat.f64_mul

def f64_mulAdd(arg1, arg2, arg3):
    return _softfloat.f64_mulAdd(arg1, arg2, arg3)
f64_mulAdd = _softfloat.f64_mulAdd

def f64_div(arg1, arg2):
    return _softfloat.f64_div(arg1, arg2)
f64_div = _softfloat.f64_div

def f64_rem(arg1, arg2):
    return _softfloat.f64_rem(arg1, arg2)
f64_rem = _softfloat.f64_rem

def f64_sqrt(arg1):
    return _softfloat.f64_sqrt(arg1)
f64_sqrt = _softfloat.f64_sqrt

def f64_eq(arg1, arg2):
    return _softfloat.f64_eq(arg1, arg2)
f64_eq = _softfloat.f64_eq

def f64_le(arg1, arg2):
    return _softfloat.f64_le(arg1, arg2)
f64_le = _softfloat.f64_le

def f64_lt(arg1, arg2):
    return _softfloat.f64_lt(arg1, arg2)
f64_lt = _softfloat.f64_lt

def f64_eq_signaling(arg1, arg2):
    return _softfloat.f64_eq_signaling(arg1, arg2)
f64_eq_signaling = _softfloat.f64_eq_signaling

def f64_le_quiet(arg1, arg2):
    return _softfloat.f64_le_quiet(arg1, arg2)
f64_le_quiet = _softfloat.f64_le_quiet

def f64_lt_quiet(arg1, arg2):
    return _softfloat.f64_lt_quiet(arg1, arg2)
f64_lt_quiet = _softfloat.f64_lt_quiet

def f64_isSignalingNaN(arg1):
    return _softfloat.f64_isSignalingNaN(arg1)
f64_isSignalingNaN = _softfloat.f64_isSignalingNaN

def convertF16ToDouble(arg1):
    return _softfloat.convertF16ToDouble(arg1)
convertF16ToDouble = _softfloat.convertF16ToDouble

def convertF32ToDouble(arg1):
    return _softfloat.convertF32ToDouble(arg1)
convertF32ToDouble = _softfloat.convertF32ToDouble

def convertF64ToDouble(arg1):
    return _softfloat.convertF64ToDouble(arg1)
convertF64ToDouble = _softfloat.convertF64ToDouble

def convertDoubleToF64(arg1):
    return _softfloat.convertDoubleToF64(arg1)
convertDoubleToF64 = _softfloat.convertDoubleToF64

def convertDoubleToF32(arg1):
    return _softfloat.convertDoubleToF32(arg1)
convertDoubleToF32 = _softfloat.convertDoubleToF32

def convertDoubleToF16(arg1):
    return _softfloat.convertDoubleToF16(arg1)
convertDoubleToF16 = _softfloat.convertDoubleToF16

def printBinary(arg1, arg2):
    return _softfloat.printBinary(arg1, arg2)
printBinary = _softfloat.printBinary

def printHex(arg1):
    return _softfloat.printHex(arg1)
printHex = _softfloat.printHex

def extF80M_to_ui32(arg1, arg2, arg3):
    return _softfloat.extF80M_to_ui32(arg1, arg2, arg3)
extF80M_to_ui32 = _softfloat.extF80M_to_ui32

def extF80M_to_ui64(arg1, arg2, arg3):
    return _softfloat.extF80M_to_ui64(arg1, arg2, arg3)
extF80M_to_ui64 = _softfloat.extF80M_to_ui64

def extF80M_to_i32(arg1, arg2, arg3):
    return _softfloat.extF80M_to_i32(arg1, arg2, arg3)
extF80M_to_i32 = _softfloat.extF80M_to_i32

def extF80M_to_i64(arg1, arg2, arg3):
    return _softfloat.extF80M_to_i64(arg1, arg2, arg3)
extF80M_to_i64 = _softfloat.extF80M_to_i64

def extF80M_to_ui32_r_minMag(arg1, arg2):
    return _softfloat.extF80M_to_ui32_r_minMag(arg1, arg2)
extF80M_to_ui32_r_minMag = _softfloat.extF80M_to_ui32_r_minMag

def extF80M_to_ui64_r_minMag(arg1, arg2):
    return _softfloat.extF80M_to_ui64_r_minMag(arg1, arg2)
extF80M_to_ui64_r_minMag = _softfloat.extF80M_to_ui64_r_minMag

def extF80M_to_i32_r_minMag(arg1, arg2):
    return _softfloat.extF80M_to_i32_r_minMag(arg1, arg2)
extF80M_to_i32_r_minMag = _softfloat.extF80M_to_i32_r_minMag

def extF80M_to_i64_r_minMag(arg1, arg2):
    return _softfloat.extF80M_to_i64_r_minMag(arg1, arg2)
extF80M_to_i64_r_minMag = _softfloat.extF80M_to_i64_r_minMag

def extF80M_to_f16(arg1):
    return _softfloat.extF80M_to_f16(arg1)
extF80M_to_f16 = _softfloat.extF80M_to_f16

def extF80M_to_f32(arg1):
    return _softfloat.extF80M_to_f32(arg1)
extF80M_to_f32 = _softfloat.extF80M_to_f32

def extF80M_to_f64(arg1):
    return _softfloat.extF80M_to_f64(arg1)
extF80M_to_f64 = _softfloat.extF80M_to_f64

def extF80M_to_f128M(arg1, arg2):
    return _softfloat.extF80M_to_f128M(arg1, arg2)
extF80M_to_f128M = _softfloat.extF80M_to_f128M

def extF80M_roundToInt(arg1, arg2, arg3, arg4):
    return _softfloat.extF80M_roundToInt(arg1, arg2, arg3, arg4)
extF80M_roundToInt = _softfloat.extF80M_roundToInt

def extF80M_add(arg1, arg2, arg3):
    return _softfloat.extF80M_add(arg1, arg2, arg3)
extF80M_add = _softfloat.extF80M_add

def extF80M_sub(arg1, arg2, arg3):
    return _softfloat.extF80M_sub(arg1, arg2, arg3)
extF80M_sub = _softfloat.extF80M_sub

def extF80M_mul(arg1, arg2, arg3):
    return _softfloat.extF80M_mul(arg1, arg2, arg3)
extF80M_mul = _softfloat.extF80M_mul

def extF80M_div(arg1, arg2, arg3):
    return _softfloat.extF80M_div(arg1, arg2, arg3)
extF80M_div = _softfloat.extF80M_div

def extF80M_rem(arg1, arg2, arg3):
    return _softfloat.extF80M_rem(arg1, arg2, arg3)
extF80M_rem = _softfloat.extF80M_rem

def extF80M_sqrt(arg1, arg2):
    return _softfloat.extF80M_sqrt(arg1, arg2)
extF80M_sqrt = _softfloat.extF80M_sqrt

def extF80M_eq(arg1, arg2):
    return _softfloat.extF80M_eq(arg1, arg2)
extF80M_eq = _softfloat.extF80M_eq

def extF80M_le(arg1, arg2):
    return _softfloat.extF80M_le(arg1, arg2)
extF80M_le = _softfloat.extF80M_le

def extF80M_lt(arg1, arg2):
    return _softfloat.extF80M_lt(arg1, arg2)
extF80M_lt = _softfloat.extF80M_lt

def extF80M_eq_signaling(arg1, arg2):
    return _softfloat.extF80M_eq_signaling(arg1, arg2)
extF80M_eq_signaling = _softfloat.extF80M_eq_signaling

def extF80M_le_quiet(arg1, arg2):
    return _softfloat.extF80M_le_quiet(arg1, arg2)
extF80M_le_quiet = _softfloat.extF80M_le_quiet

def extF80M_lt_quiet(arg1, arg2):
    return _softfloat.extF80M_lt_quiet(arg1, arg2)
extF80M_lt_quiet = _softfloat.extF80M_lt_quiet

def extF80M_isSignalingNaN(arg1):
    return _softfloat.extF80M_isSignalingNaN(arg1)
extF80M_isSignalingNaN = _softfloat.extF80M_isSignalingNaN

def f128M_to_ui32(arg1, arg2, arg3):
    return _softfloat.f128M_to_ui32(arg1, arg2, arg3)
f128M_to_ui32 = _softfloat.f128M_to_ui32

def f128M_to_ui64(arg1, arg2, arg3):
    return _softfloat.f128M_to_ui64(arg1, arg2, arg3)
f128M_to_ui64 = _softfloat.f128M_to_ui64

def f128M_to_i32(arg1, arg2, arg3):
    return _softfloat.f128M_to_i32(arg1, arg2, arg3)
f128M_to_i32 = _softfloat.f128M_to_i32

def f128M_to_i64(arg1, arg2, arg3):
    return _softfloat.f128M_to_i64(arg1, arg2, arg3)
f128M_to_i64 = _softfloat.f128M_to_i64

def f128M_to_ui32_r_minMag(arg1, arg2):
    return _softfloat.f128M_to_ui32_r_minMag(arg1, arg2)
f128M_to_ui32_r_minMag = _softfloat.f128M_to_ui32_r_minMag

def f128M_to_ui64_r_minMag(arg1, arg2):
    return _softfloat.f128M_to_ui64_r_minMag(arg1, arg2)
f128M_to_ui64_r_minMag = _softfloat.f128M_to_ui64_r_minMag

def f128M_to_i32_r_minMag(arg1, arg2):
    return _softfloat.f128M_to_i32_r_minMag(arg1, arg2)
f128M_to_i32_r_minMag = _softfloat.f128M_to_i32_r_minMag

def f128M_to_i64_r_minMag(arg1, arg2):
    return _softfloat.f128M_to_i64_r_minMag(arg1, arg2)
f128M_to_i64_r_minMag = _softfloat.f128M_to_i64_r_minMag

def f128M_to_f16(arg1):
    return _softfloat.f128M_to_f16(arg1)
f128M_to_f16 = _softfloat.f128M_to_f16

def f128M_to_f32(arg1):
    return _softfloat.f128M_to_f32(arg1)
f128M_to_f32 = _softfloat.f128M_to_f32

def f128M_to_f64(arg1):
    return _softfloat.f128M_to_f64(arg1)
f128M_to_f64 = _softfloat.f128M_to_f64

def f128M_to_extF80M(arg1, arg2):
    return _softfloat.f128M_to_extF80M(arg1, arg2)
f128M_to_extF80M = _softfloat.f128M_to_extF80M

def f128M_roundToInt(arg1, arg2, arg3, arg4):
    return _softfloat.f128M_roundToInt(arg1, arg2, arg3, arg4)
f128M_roundToInt = _softfloat.f128M_roundToInt

def f128M_add(arg1, arg2, arg3):
    return _softfloat.f128M_add(arg1, arg2, arg3)
f128M_add = _softfloat.f128M_add

def f128M_sub(arg1, arg2, arg3):
    return _softfloat.f128M_sub(arg1, arg2, arg3)
f128M_sub = _softfloat.f128M_sub

def f128M_mul(arg1, arg2, arg3):
    return _softfloat.f128M_mul(arg1, arg2, arg3)
f128M_mul = _softfloat.f128M_mul

def f128M_mulAdd(arg1, arg2, arg3, arg4):
    return _softfloat.f128M_mulAdd(arg1, arg2, arg3, arg4)
f128M_mulAdd = _softfloat.f128M_mulAdd

def f128M_div(arg1, arg2, arg3):
    return _softfloat.f128M_div(arg1, arg2, arg3)
f128M_div = _softfloat.f128M_div

def f128M_rem(arg1, arg2, arg3):
    return _softfloat.f128M_rem(arg1, arg2, arg3)
f128M_rem = _softfloat.f128M_rem

def f128M_sqrt(arg1, arg2):
    return _softfloat.f128M_sqrt(arg1, arg2)
f128M_sqrt = _softfloat.f128M_sqrt

def f128M_eq(arg1, arg2):
    return _softfloat.f128M_eq(arg1, arg2)
f128M_eq = _softfloat.f128M_eq

def f128M_le(arg1, arg2):
    return _softfloat.f128M_le(arg1, arg2)
f128M_le = _softfloat.f128M_le

def f128M_lt(arg1, arg2):
    return _softfloat.f128M_lt(arg1, arg2)
f128M_lt = _softfloat.f128M_lt

def f128M_eq_signaling(arg1, arg2):
    return _softfloat.f128M_eq_signaling(arg1, arg2)
f128M_eq_signaling = _softfloat.f128M_eq_signaling

def f128M_le_quiet(arg1, arg2):
    return _softfloat.f128M_le_quiet(arg1, arg2)
f128M_le_quiet = _softfloat.f128M_le_quiet

def f128M_lt_quiet(arg1, arg2):
    return _softfloat.f128M_lt_quiet(arg1, arg2)
f128M_lt_quiet = _softfloat.f128M_lt_quiet

def f128M_isSignalingNaN(arg1):
    return _softfloat.f128M_isSignalingNaN(arg1)
f128M_isSignalingNaN = _softfloat.f128M_isSignalingNaN


def convertToColor(i, fs, es):
   orig="{0:b}".format(i).zfill(fs)
   m=0
   regime=1
   exponent=0
   firstFrac = 1
   colored=""
   if es>0:
       exponent = 1
       e=0
   for c in orig:
       if m==0:
           colored+="\033[1;37;41m"+c+"\033[0m"              
       elif exponent==1:
           if e==0:
              colored+="\033[1;37;44m"+c
           else:
              colored+=c
           e+=1
           if e==es:
              colored+="\033[0m"
              exponent = 0
       else:
           if firstFrac==1:
              colored+="\033[1;37;40m"+c
              firstFrac=0
           else:
              colored+=c
       m+=1
       if (m!=fs and m%8==0):
           colored+=" "

   return colored+"\033[0m"

class float64:
   def __init__(self, value=None, bits=None):
       try:
           if bits is not None:
               if isinstance(bits, (int)):
                   self.v = float64_t()
                   self.v.v = bits
               else:
                   raise Exception("Bits can only be set with integer values")
           else:
               if value is None:
                   self.v = float64_t()
                   self.v.v = 0
               elif isinstance(value, (int)):
                   self.v = _softfloat.i64_to_f64(value)
               else:
                   self.v = _softfloat.convertDoubleToF64(value)
       except Exception as error:
           print(repr(error))
   def type(self):
       return 'float64'
   def __add__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_add(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_add(self.v, _softfloat.convertDoubleToF64(other))
          else:           
              a.v = _softfloat.f64_add(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for +: float64 and ",other.type())          
   def __radd__(self, other):
       return self.__add__(other)  
   def __sub__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_sub(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_sub(self.v, _softfloat.convertDoubleToF64(other))
          else:
              a.v = _softfloat.f64_sub(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float64 and ",other.type())      
   def __rsub__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_sub(_softfloat.i64_to_f64(other), self.v)
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_sub(_softfloat.convertDoubleToF64(other), self.v)
          else:
              a.v = _softfloat.f64_sub(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float64 and ",other.type())  
   def __mul__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_mul(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_mul(self.v, _softfloat.convertDoubleToF64(other))
          else:
              a.v = _softfloat.f64_mul(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for *: float64 and ",other.type())   
   def __rmul__(self, other):
       return self.__mul__(other)  
   def __div__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_div(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_div(self.v, _softfloat.convertDoubleToF64(other))
          else:
              a.v = _softfloat.f64_div(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for /: float64 and ",other.type())   
   def __truediv__(self, other):
       return self.__div(other)      
   def __rdiv__(self, other):
       try:
          a = float64(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f64_div(_softfloat.i64_to_f64(other), self.v)
          elif isinstance(other, (float)):
              a.v = _softfloat.f64_div(_softfloat.convertDoubleToF64(other), self.v)
          else:
              a.v = _softfloat.f64_div(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for *: float64 and ",other.type())  
   def __rtruediv__(self, other):
       return self.__rdiv__(other)
   def __eq__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f64_eq(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              return _softfloat.f64_eq(self.v, _softfloat.convertDoubleToF64(other))
          else:
              return _softfloat.f64_eq(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for ==: float64 and ",other.type())   
   def __ne__(self, other):
       try:                                                                                     
          if isinstance(other, (int)):
              return not(_softfloat.f64_eq(self.v, _softfloat.i64_to_f64(other)))
          elif isinstance(other, (float)):
              return not(_softfloat.f64_eq(self.v, _softfloat.convertDoubleToF64(other)))
          else:
              return not(_softfloat.f64_eq(self.v, other.v))
       except TypeError:
          print("TypeError: Unsupported operand type(s) for !=: float64 and ",other.type())
   def __le__(self, other):
       try:        
          if isinstance(other, (int)):
              return _softfloat.f64_le(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              return _softfloat.f64_le(self.v, _softfloat.convertDoubleToF64(other))
          else:
              return _softfloat.f64_le(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <=: float64 and ",other.type()) 
   def __lt__(self, other):
       try:   
          if isinstance(other, (int)):
              return _softfloat.f64_lt(self.v, _softfloat.i64_to_f64(other))
          elif isinstance(other, (float)):
              return _softfloat.f64_lt(self.v, _softfloat.convertDoubleToF64(other))
          else:
              return _softfloat.f64_lt(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <: float64 and ",other.type())
   def __ge__(self, other):
       try:   
          if isinstance(other, (int)):
              return _softfloat.f64_le(_softfloat.i64_to_f64(other), self.v)
          elif isinstance(other, (float)):
              return _softfloat.f64_le(_softfloat.convertDoubleToF64(other), self.v)
          else:
              return _softfloat.f64_le(other.v, self.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for >=: float64 and ",other.type())
   def __gt__(self, other):
       try:   
          if isinstance(other, (int)):
              return _softfloat.f64_lt(_softfloat.i64_to_f64(other), self.v)
          elif isinstance(other, (float)):
              return _softfloat.f64_lt(_softfloat.convertDoubleToF64(other), self.v)
          else:
              return _softfloat.f64_lt(other.v, self.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for >: float64 and ",other.type())
   def __rshift__(self, other):
       a = float64(0)
       a.v = self.v.__rshift__(other)
       return a
   def __lshift__(self, other):
       a = float64(0)
       a.v = self.v.__lshift__(other)
       return a
   def __pos__(self):
       return self
   def __neg__(self):
       a = float64(0)
       a.v = self.v.__neg__()
       return a
   def __abs__(self):
       a = float64(0)
       a.v = self.v.__abs__()
       return a
   def __invert__(self):
       self.v = self.v.__invert__()
       return self   
   def __and__(self, other):
       a = float64(0)
       a.v = self.v.__and__(other.v)
       return a
   def __xor__(self, other):
       a = float64(0)
       a.v = self.v.__xor__(other.v)
       return a
   def __or__(self, other):
       a = float64(0)
       a.v = self.v.__or__(other.v)
       return a
   def fma(self, other1, other2):
       try:   
          a = float64(0)
          if isinstance(other1, (int)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f64_mulAdd(_softfloat.i64_to_f64(other1), _softfloat.i64_to_f64(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f64_mulAdd(_softfloat.i64_to_f64(other1), _softfloat.convertDoubleToF64(other2), self.v)
              else:
                  a.v = _softfloat.f64_mulAdd(_softfloat.i64_to_f64(other1), other2.v, self.v)
          elif isinstance(other1, (float)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f64_mulAdd(_softfloat.convertDoubleToF64(other1), _softfloat.i64_to_f64(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f64_mulAdd(_softfloat.convertDoubleToF64(other1), _softfloat.convertDoubleToF64(other2), self.v)
              else:
                  a.v = _softfloat.f64_mulAdd(_softfloat.convertDoubleToF64(other1), other2.v, self.v)
          else:
              if isinstance(other2, (int)):
                  a.v = _softfloat.f64_mulAdd(self.v, other1.v, _softfloat.i64_to_f64(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f64_mulAdd(other1.v, _softfloat.convertDoubleToF64(other2), self.v)
              else:
                  a.v = _softfloat.f64_mulAdd(other1.v, other2.v, self.v)   
          return a
       except TypeError:
          print("TypeError: Unsupported fused operand (fma) among mixed precison float types")
   def toFloat16(self):
       a = float16(0)
       a.v = _softfloat.f64_to_f16(self.v)
       return a
   def toFloat32(self):
       a = float32(0)
       a.v = _softfloat.f64_to_f32(self.v)
       return a
   def toRInt(self):
       return _softfloat.f64_to_i64(self.v)
   def toInt(self):
       return int(struct.unpack('>d', struct.pack('>Q', self.v.v))[0])
   def rint(self):
       self.v = _softfloat.f64_roundToInt(self.v)
       return self
   def sqrt(self):
       self.v = _softfloat.f64_sqrt(self.v)
       return self
   def __repr__(self):
       a = float(struct.unpack('>d', struct.pack('>Q', self.v.v))[0])
       return str(a)
   def __str__(self):
       a = float(struct.unpack('>d', struct.pack('>Q', self.v.v))[0])
       return str(a)
   def __int__(self):
       return int(struct.unpack('>d', struct.pack('>Q', self.v.v))[0])
   def __float__(self):
       return struct.unpack('>d', struct.pack('>Q', self.v.v))[0]
   def fromBits(self, value):
       self.v.fromBits(value)
   def toBinary(self):
       self.v.toBits()
   def toBinaryFormatted(self):
       print(convertToColor(self.v.v, 64, 11))
   def toHex(self):
       self.v.toHex()


class float16:
   def __init__(self, value=None, bits=None):
       try:
           if bits is not None:
               if isinstance(bits, (int)):
                   self.v = float16_t()
                   self.v.v = bits & 0xFFFF
               else:
                   raise Exception("Bits can only be set with integer values")
           else:
               if value is None:
                   self.v = float16_t()
                   self.v.v = 0
               elif isinstance(value, (int)):
                   self.v = _softfloat.i64_to_f16(value)
               else:
                   self.v = _softfloat.convertDoubleToF16(value)
       except Exception as error:
           print(repr(error))
   def type(self):
       return 'float16'
   def __add__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_add(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_add(self.v, _softfloat.convertDoubleToF16(other))
          else:
              a.v = _softfloat.f16_add(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for +: float16 and ",other.type())     
   def __radd__(self, other):
       return self.__add__(other)  
   def __sub__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_sub(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_sub(self.v, _softfloat.convertDoubleToF16(other))
          else:
              a.v = _softfloat.f16_sub(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float16 and ",other.type()) 
   def __rsub__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_sub(_softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_sub(_softfloat.convertDoubleToF16(other), self.v)
          else:
              a.v = _softfloat.f16_sub(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float16 and ",other.type())  
   def __mul__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_mul(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_mul(self.v, _softfloat.convertDoubleToF16(other))
          else:
              a.v = _softfloat.f16_mul(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for *: float16 and ",other.type()) 
   def __rmul__(self, other):
       return self.__mul__(other)  
   def __div__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_div(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_div(self.v, _softfloat.convertDoubleToF16(other))
          else:
              a.v = _softfloat.f16_div(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for /: float16 and ",other.type()) 
   def __truediv__(self, other):
       return self.__div__(other)
   def __rdiv__(self, other):
       try:
          a = float16(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f16_div(_softfloat.i64_to_f16(other), self.v)
          elif isinstance(other, (float)):
              a.v = _softfloat.f16_div(_softfloat.convertDoubleToF16(other), self.v)
          else:
              a.v = _softfloat.f16_div(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for /: float16 and ",other.type()) 
   def __rtruediv__(self, other):
       return self.__rdiv__(other)
   def __eq__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f16_eq(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              return _softfloat.f16_eq(self.v, _softfloat.convertDoubleToF16(other))
          else:
              return _softfloat.f16_eq(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for ==: float16 and ",other.type()) 
   def __ne__(self, other):  
       try:                                                                                          
          if isinstance(other, (int)):
              return not(_softfloat.f16_eq(self.v, _softfloat.i64_to_f16(other)))
          elif isinstance(other, (float)):
              return not(_softfloat.f16_eq(self.v, _softfloat.convertDoubleToF16(other)))
          else:
              return not(_softfloat.f16_eq(self.v, other.v))
       except TypeError:
          print("TypeError: Unsupported operand type(s) for !=: float16 and ",other.type())
   def __le__(self, other):
       try:             
          if isinstance(other, (int)):
              return _softfloat.f16_le(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              return _softfloat.f16_le(self.v, _softfloat.convertDoubleToF16(other))
          else:
              return _softfloat.f16_le(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <=: float16 and ",other.type()) 
   def __lt__(self, other):
       try:             
          if isinstance(other, (int)):
              return _softfloat.f16_lt(self.v, _softfloat.i64_to_f16(other))
          elif isinstance(other, (float)):
              return _softfloat.f16_lt(self.v, _softfloat.convertDoubleToF16(other))
          else:
              return _softfloat.f16_lt(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <: float16 and ",other.type()) 
   def __ge__(self, other):
       try:    
          if isinstance(other, (int)):
              return _softfloat.f16_le(_softfloat.i64_to_f16(other), self.v)
          elif isinstance(other, (float)):
              return _softfloat.f16_le(_softfloat.convertDoubleToF16(other), self.v)
          else:
              return _softfloat.f16_le(other.v, self.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for >=: float16 and ",other.type())  
   def __gt__(self, other):
       if isinstance(other, (int)):
           return _softfloat.f16_lt(_softfloat.i64_to_f16(other), self.v)
       elif isinstance(other, (float)):
           return _softfloat.f16_lt(_softfloat.convertDoubleToF16(other), self.v)
       else:
           return _softfloat.f16_lt(other.v, self.v)
   def __rshift__(self, other):
       a = float16(0)
       a.v = self.v.__rshift__(other)
       return a
   def __lshift__(self, other):
       a = float16(0)
       a.v = self.v.__lshift__(other)
       return a
   def __pos__(self):
       return self
   def __neg__(self):
       a = float16(0)
       a.v = self.v.__neg__()
       return a
   def __abs__(self):
       a = float16(0)
       a.v = self.v.__abs__()
       return a
   def __invert__(self):
       self.v = self.v.__invert__()
       return self   
   def __and__(self, other):
       a = float16(0)
       a.v = self.v.__and__(other.v)
       return a
   def __xor__(self, other):
       a = float16(0)
       a.v = self.v.__xor__(other.v)
       return a
   def __or__(self, other):
       a = float16(0)
       a.v = self.v.__or__(other.v)
       return a
   def fma(self, other1, other2):
       try:
          a = float16(0)
          if isinstance(other1, (int)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f16_mulAdd(_softfloat.i64_to_f16(other1), _softfloat.i64_to_f16(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f16_mulAdd(_softfloat.i64_to_f16(other1), _softfloat.convertDoubleToF16(other2), self.v)
              else:
                  a.v = _softfloat.f16_mulAdd(_softfloat.i64_to_f16(other1), other2.v, self.v)
          elif isinstance(other1, (float)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f16_mulAdd(_softfloat.convertDoubleToF16(other1), _softfloat.i64_to_f16(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f16_mulAdd(_softfloat.convertDoubleToF16(other1), _softfloat.convertDoubleToF16(other2), self.v)
              else:
                  a.v = _softfloat.f16_mulAdd(_softfloat.convertDoubleToF16(other1), other2.v, self.v)
          else:
              if isinstance(other2, (int)):
                  a.v = _softfloat.f16_mulAdd(other1.v, _softfloat.i64_to_f16(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f16_mulAdd(other1.v, _softfloat.convertDoubleToF16(other2), self.v)
              else:
                  a.v = _softfloat.f16_mulAdd(other1.v, other2.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported fused operand (fma) among mixed precison float types")
   def toFloat64(self):
       a = float64(0)
       a.v = _softfloat.f16_to_f64(self.v)
       return a
   def toFloat32(self):
       a = float32(0)
       a.v = _softfloat.f16_to_f32(self.v)
       return a
   def toRInt(self):
       return _softfloat.f16_to_i64(self.v)
   def toInt(self):
       return int(_softfloat.convertF16ToDouble(self.v))
   def rint(self):
       self.v = _softfloat.f16_roundToInt(self.v)
       return self
   def sqrt(self):
       self.v = _softfloat.f16_sqrt(self.v)
       return self
   def __repr__(self):
       a = float(_softfloat.convertF16ToDouble(self.v))
       return str(a)
   def __str__(self):
       a = float(_softfloat.convertF16ToDouble(self.v))
       return str(a)
   def __int__(self):
       return int(_softfloat.convertF16ToDouble(self.v))
   def __float__(self):
       return float(_softfloat.convertF16ToDouble(self.v))
   def fromBits(self, value):
       self.v.fromBits(value)
   def toBinary(self):
       self.v.toBits()
   def toBinaryFormatted(self):
       print(convertToColor(self.v.v, 16, 5))
   def toHex(self):
       self.v.toHex()



class float32:
   def __init__(self, value=None, bits=None):
       try:
           if bits is not None:
               if isinstance(bits, (int)):
                   self.v = float32_t()
                   self.v.v = bits & 0xFFFFFFFF
               else:
                   raise Exception("Bits can only be set with integer values")
           else:
               if value is None:
                   self.v = float32_t()
                   self.v.v = 0
               elif isinstance(value, (int)):
                   self.v = _softfloat.i64_to_f32(value)
               else:
                   self.v = _softfloat.convertDoubleToF32(value)
       except Exception as error:
           print(repr(error));
   def type(self):
       return 'float32'
   def __add__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_add(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_add(self.v, _softfloat.convertDoubleToF32(other))
          else:
              a.v = _softfloat.f32_add(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for +: float32 and ",other.type())     
   def __radd__(self, other):
       return self.__add__(other)  
   def __sub__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_sub(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_sub(self.v, _softfloat.convertDoubleToF32(other))
          else:
              a.v = _softfloat.f32_sub(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float32 and ",other.type())  
   def __rsub__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_sub(_softfloat.i64_to_f32(other), self.v)
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_sub(_softfloat.convertDoubleToF32(other), self.v)
          else:
              a.v = _softfloat.f32_sub(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for -: float32 and ",other.type())    
   def __mul__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_mul(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_mul(self.v, _softfloat.convertDoubleToF32(other))
          else:
              a.v = _softfloat.f32_mul(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for *: float32 and ",other.type())     
   def __rmul__(self, other):
       return self.__mul__(other)  
   def __div__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_div(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_div(self.v, _softfloat.convertDoubleToF32(other))
          else:
              a.v = _softfloat.f32_div(self.v, other.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for /: float32 and ",other.type())   
   def __truediv__(self, other):
       return self.__div__(other)
   def __rdiv__(self, other):
       try:
          a = float32(0)
          if isinstance(other, (int)):
              a.v = _softfloat.f32_div(_softfloat.i64_to_f32(other), self.v)
          elif isinstance(other, (float)):
              a.v = _softfloat.f32_div(_softfloat.convertDoubleToF32(other), self.v)
          else:
              a.v = _softfloat.f32_div(other.v, self.v)
          return a
       except TypeError:
          print("TypeError: Unsupported operand type(s) for /: float32 and ",other.type())     
   def __rtruediv__(self, other):
       return self.__rdiv__(other)
   def __eq__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f32_eq(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              return _softfloat.f32_eq(self.v, _softfloat.convertDoubleToF32(other))
          else:
              return _softfloat.f32_eq(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for ==: float32 and ",other.type())     
   def __ne__(self, other):  
       try:                                                                                
          if isinstance(other, (int)):
              return not(_softfloat.f32_eq(self.v, _softfloat.i64_to_f32(other)))
          elif isinstance(other, (float)):
              return not(_softfloat.f32_eq(self.v, _softfloat.convertDoubleToF32(other)))
          else:
              return not(_softfloat.f32_eq(self.v, other.v))
       except TypeError:
          print("TypeError: Unsupported operand type(s) for !=: float32 and ",other.type())    
   def __le__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f32_le(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              return _softfloat.f32_le(self.v, _softfloat.convertDoubleToF32(other))
          else:
              return _softfloat.f32_le(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <=: float32 and ",other.type())  
   def __lt__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f32_lt(self.v, _softfloat.i64_to_f32(other))
          elif isinstance(other, (float)):
              return _softfloat.f32_lt(self.v, _softfloat.convertDoubleToF32(other))
          else:
              return _softfloat.f32_lt(self.v, other.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for <: float32 and ",other.type())  
   def __ge__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f32_le(_softfloat.i64_to_f32(other), self.v)
          elif isinstance(other, (float)):
              return _softfloat.f32_le(_softfloat.convertDoubleToF32(other), self.v)
          else:
              return _softfloat.f32_le(other.v, self.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for >=: float32 and ",other.type())  
   def __gt__(self, other):
       try:
          if isinstance(other, (int)):
              return _softfloat.f32_lt(_softfloat.i64_to_f32(other), self.v)
          elif isinstance(other, (float)):
              return _softfloat.f32_lt(_softfloat.convertDoubleToF32(other), self.v)
          else:
              return _softfloat.f32_lt(other.v, self.v)
       except TypeError:
          print("TypeError: Unsupported operand type(s) for >: float32 and ",other.type())  
   def __rshift__(self, other):
       a = float32(0)
       a.v = self.v.__rshift__(other)
       return a
   def __lshift__(self, other):
       a = float32(0)
       a.v = self.v.__lshift__(other)
       return a
   def __pos__(self):
       return self
   def __neg__(self):
       a = float32(0)
       a.v = self.v.__neg__()
       return a
   def __abs__(self):
       a = float32(0)
       a.v = self.v.__abs__()
       return a
   def __invert__(self):
       self.v = self.v.__invert__()
       return self   
   def __and__(self, other):
       a = float32(0)
       a.v = self.v.__and__(other.v)
       return a
   def __xor__(self, other):
       a = float32(0)
       a.v = self.v.__xor__(other.v)
       return a
   def __or__(self, other):
       a = float32(0)
       a.v = self.v.__or__(other.v)
       return a
   def fma(self, other1, other2):
       try:
          a = float32(0)
          if isinstance(other1, (int)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f32_mulAdd(_softfloat.i64_to_f32(other1), _softfloat.i64_to_f32(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f32_mulAdd(_softfloat.i64_to_f32(other1), _softfloat.convertDoubleToF32(other2), self.v)
              else:
                  a.v = _softfloat.f32_mulAdd(_softfloat.i64_to_f32(other1), other2.v, self.v)
          elif isinstance(other1, (float)):
              if isinstance(other2, (int)):
                  a.v = _softfloat.f32_mulAdd(_softfloat.convertDoubleToF32(other1), _softfloat.i64_to_f32(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f32_mulAdd(_softfloat.convertDoubleToF32(other1), _softfloat.convertDoubleToF32(other2), self.v)
              else:
                  a.v = _softfloat.f32_mulAdd(_softfloat.convertDoubleToF32(other1), other2.v, self.v)
          else:
              if isinstance(other2, (int)):
                  a.v = _softfloat.f32_mulAdd(other1.v, _softfloat.i64_to_f32(other2), self.v)
              elif isinstance(other2, (float)):
                  a.v = _softfloat.f32_mulAdd(other1.v, _softfloat.convertDoubleToF32(other2), self.v)
              else:
                  a.v = _softfloat.f32_mulAdd(other1.v, other2.v, self.v)   
          return a
       except TypeError:
          print("TypeError: Unsupported fused operand (fma) among mixed precison float types")
   def toFloat64(self):
       a = float64(0)
       a.v = _softfloat.f32_to_f64(self.v)
       return a
   def toFloat16(self):
       a = float16(0)
       a.v = _softfloat.f32_to_f16(self.v)
       return a
   def toRInt(self):
       return _softfloat.f32_to_i64(self.v)
   def toInt(self):
       return int(_softfloat.convertF32ToDouble(self.v))
   def rint(self):
       self.v = _softfloat.f32_roundToInt(self.v)
       return self
   def sqrt(self):
       self.v = _softfloat.f32_sqrt(self.v)
       return self
   def __repr__(self):
       a = float(_softfloat.convertF32ToDouble(self.v))
       return str(a)
   def __str__(self):
       a = float(_softfloat.convertF32ToDouble(self.v))
       return str(a)
   def __int__(self):
       return int(_softfloat.convertF32ToDouble(self.v))
   def __float__(self):
       return float(_softfloat.convertF32ToDouble(self.v))
   def fromBits(self, value):
       self.v.fromBits(value)
   def toBinary(self):
       self.v.toBits()
   def toBinaryFormatted(self):
       print(convertToColor(self.v.v, 32, 8))
   def toHex(self):
       self.v.toHex()



# This file is compatible with both classic and new-style classes.

cvar = _softfloat.cvar

