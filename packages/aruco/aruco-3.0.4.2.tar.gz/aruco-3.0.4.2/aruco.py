# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_aruco', [dirname(__file__)])
        except ImportError:
            import _aruco
            return _aruco
        if fp is not None:
            try:
                _mod = imp.load_module('_aruco', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _aruco = swig_import_helper()
    del swig_import_helper
else:
    import _aruco
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


import collections
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aruco.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _aruco.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _aruco.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _aruco.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _aruco.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _aruco.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _aruco.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _aruco.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _aruco.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _aruco.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _aruco.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _aruco.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _aruco.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _aruco.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _aruco.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _aruco.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _aruco.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _aruco.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class VectorInt(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _aruco.VectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _aruco.VectorInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _aruco.VectorInt___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _aruco.VectorInt___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _aruco.VectorInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _aruco.VectorInt___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _aruco.VectorInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _aruco.VectorInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _aruco.VectorInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _aruco.VectorInt___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _aruco.VectorInt_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _aruco.VectorInt_append(self, x)

    def empty(self) -> "bool":
        return _aruco.VectorInt_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _aruco.VectorInt_size(self)

    def swap(self, v: 'VectorInt') -> "void":
        return _aruco.VectorInt_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _aruco.VectorInt_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _aruco.VectorInt_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _aruco.VectorInt_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _aruco.VectorInt_rend(self)

    def clear(self) -> "void":
        return _aruco.VectorInt_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _aruco.VectorInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _aruco.VectorInt_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _aruco.VectorInt_erase(self, *args)

    def __init__(self, *args):
        this = _aruco.new_VectorInt(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _aruco.VectorInt_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _aruco.VectorInt_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _aruco.VectorInt_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _aruco.VectorInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _aruco.VectorInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _aruco.VectorInt_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _aruco.VectorInt_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _aruco.VectorInt_capacity(self)
    __swig_destroy__ = _aruco.delete_VectorInt
    __del__ = lambda self: None
VectorInt_swigregister = _aruco.VectorInt_swigregister
VectorInt_swigregister(VectorInt)


_aruco.ARUCO_VERSION_MAJOR_swigconstant(_aruco)
ARUCO_VERSION_MAJOR = _aruco.ARUCO_VERSION_MAJOR

_aruco.ARUCO_VERSION_MINOR_swigconstant(_aruco)
ARUCO_VERSION_MINOR = _aruco.ARUCO_VERSION_MINOR
class CameraParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CameraParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CameraParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["CameraMatrix"] = _aruco.CameraParameters_CameraMatrix_set
    __swig_getmethods__["CameraMatrix"] = _aruco.CameraParameters_CameraMatrix_get
    if _newclass:
        CameraMatrix = _swig_property(_aruco.CameraParameters_CameraMatrix_get, _aruco.CameraParameters_CameraMatrix_set)
    __swig_setmethods__["Distorsion"] = _aruco.CameraParameters_Distorsion_set
    __swig_getmethods__["Distorsion"] = _aruco.CameraParameters_Distorsion_get
    if _newclass:
        Distorsion = _swig_property(_aruco.CameraParameters_Distorsion_get, _aruco.CameraParameters_Distorsion_set)
    __swig_setmethods__["CamSize"] = _aruco.CameraParameters_CamSize_set
    __swig_getmethods__["CamSize"] = _aruco.CameraParameters_CamSize_get
    if _newclass:
        CamSize = _swig_property(_aruco.CameraParameters_CamSize_get, _aruco.CameraParameters_CamSize_set)

    def setParams(self, cameraMatrix: 'cv::Mat', distorsionCoeff: 'cv::Mat', size: 'cv::Size') -> "void":
        return _aruco.CameraParameters_setParams(self, cameraMatrix, distorsionCoeff, size)

    def __init__(self, *args):
        this = _aruco.new_CameraParameters(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def isValid(self) -> "bool":
        return _aruco.CameraParameters_isValid(self)

    def saveToFile(self, path: 'std::string', inXML: 'bool'=True) -> "void":
        return _aruco.CameraParameters_saveToFile(self, path, inXML)

    def readFromXMLFile(self, filePath: 'std::string') -> "void":
        return _aruco.CameraParameters_readFromXMLFile(self, filePath)

    def resize(self, size: 'cv::Size') -> "void":
        return _aruco.CameraParameters_resize(self, size)
    __swig_getmethods__["getCameraLocation"] = lambda x: _aruco.CameraParameters_getCameraLocation
    if _newclass:
        getCameraLocation = staticmethod(_aruco.CameraParameters_getCameraLocation)

    def glGetProjectionMatrix(self, orgImgSize: 'cv::Size', size: 'cv::Size', proj_matrix: 'double [16]', gnear: 'double', gfar: 'double', invert: 'bool'=False) -> "void":
        return _aruco.CameraParameters_glGetProjectionMatrix(self, orgImgSize, size, proj_matrix, gnear, gfar, invert)

    def OgreGetProjectionMatrix(self, orgImgSize: 'cv::Size', size: 'cv::Size', proj_matrix: 'double [16]', gnear: 'double', gfar: 'double', invert: 'bool'=False) -> "void":
        return _aruco.CameraParameters_OgreGetProjectionMatrix(self, orgImgSize, size, proj_matrix, gnear, gfar, invert)
    __swig_getmethods__["getRTMatrix"] = lambda x: _aruco.CameraParameters_getRTMatrix
    if _newclass:
        getRTMatrix = staticmethod(_aruco.CameraParameters_getRTMatrix)
    __swig_destroy__ = _aruco.delete_CameraParameters
    __del__ = lambda self: None
CameraParameters_swigregister = _aruco.CameraParameters_swigregister
CameraParameters_swigregister(CameraParameters)

def CameraParameters_getCameraLocation(Rvec: 'cv::Mat', Tvec: 'cv::Mat') -> "cv::Mat, cv::Mat":
    return _aruco.CameraParameters_getCameraLocation(Rvec, Tvec)
CameraParameters_getCameraLocation = _aruco.CameraParameters_getCameraLocation

def CameraParameters_getRTMatrix(R_: 'cv::Mat const &', T_: 'cv::Mat const &', forceType: 'int') -> "cv::Mat const &, cv::Mat const &":
    return _aruco.CameraParameters_getRTMatrix(R_, T_, forceType)
CameraParameters_getRTMatrix = _aruco.CameraParameters_getRTMatrix

class CvDrawingUtils(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CvDrawingUtils, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CvDrawingUtils, name)
    __repr__ = _swig_repr
    __swig_getmethods__["draw3dAxis"] = lambda x: _aruco.CvDrawingUtils_draw3dAxis
    if _newclass:
        draw3dAxis = staticmethod(_aruco.CvDrawingUtils_draw3dAxis)
    __swig_getmethods__["draw3dCube"] = lambda x: _aruco.CvDrawingUtils_draw3dCube
    if _newclass:
        draw3dCube = staticmethod(_aruco.CvDrawingUtils_draw3dCube)

    def __init__(self):
        this = _aruco.new_CvDrawingUtils()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_CvDrawingUtils
    __del__ = lambda self: None
CvDrawingUtils_swigregister = _aruco.CvDrawingUtils_swigregister
CvDrawingUtils_swigregister(CvDrawingUtils)

def CvDrawingUtils_draw3dAxis(*args) -> "cv::Mat &":
    return _aruco.CvDrawingUtils_draw3dAxis(*args)
CvDrawingUtils_draw3dAxis = _aruco.CvDrawingUtils_draw3dAxis

def CvDrawingUtils_draw3dCube(Image: 'cv::Mat &', m: 'Marker &', CP: 'CameraParameters', setYperpendicular: 'bool'=False) -> "cv::Mat &":
    return _aruco.CvDrawingUtils_draw3dCube(Image, m, CP, setYperpendicular)
CvDrawingUtils_draw3dCube = _aruco.CvDrawingUtils_draw3dCube

class Debug(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Debug, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Debug, name)
    __repr__ = _swig_repr
    __swig_getmethods__["init"] = lambda x: _aruco.Debug_init
    if _newclass:
        init = staticmethod(_aruco.Debug_init)
    __swig_getmethods__["setLevel"] = lambda x: _aruco.Debug_setLevel
    if _newclass:
        setLevel = staticmethod(_aruco.Debug_setLevel)
    __swig_getmethods__["getLevel"] = lambda x: _aruco.Debug_getLevel
    if _newclass:
        getLevel = staticmethod(_aruco.Debug_getLevel)
    __swig_getmethods__["addString"] = lambda x: _aruco.Debug_addString
    if _newclass:
        addString = staticmethod(_aruco.Debug_addString)
    __swig_getmethods__["getString"] = lambda x: _aruco.Debug_getString
    if _newclass:
        getString = staticmethod(_aruco.Debug_getString)
    __swig_getmethods__["getFileName"] = lambda x: _aruco.Debug_getFileName
    if _newclass:
        getFileName = staticmethod(_aruco.Debug_getFileName)

    def __init__(self):
        this = _aruco.new_Debug()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_Debug
    __del__ = lambda self: None
Debug_swigregister = _aruco.Debug_swigregister
Debug_swigregister(Debug)

def Debug_init() -> "void":
    return _aruco.Debug_init()
Debug_init = _aruco.Debug_init

def Debug_setLevel(l: 'int') -> "void":
    return _aruco.Debug_setLevel(l)
Debug_setLevel = _aruco.Debug_setLevel

def Debug_getLevel() -> "int":
    return _aruco.Debug_getLevel()
Debug_getLevel = _aruco.Debug_getLevel

def Debug_addString(label: 'std::string &', data: 'std::string &') -> "void":
    return _aruco.Debug_addString(label, data)
Debug_addString = _aruco.Debug_addString

def Debug_getString(str: 'std::string &') -> "std::string":
    return _aruco.Debug_getString(str)
Debug_getString = _aruco.Debug_getString

def Debug_getFileName(filepath: 'std::string') -> "std::string":
    return _aruco.Debug_getFileName(filepath)
Debug_getFileName = _aruco.Debug_getFileName

class Dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionary, name)
    __repr__ = _swig_repr
    ARUCO_MIP_36h12 = _aruco.Dictionary_ARUCO_MIP_36h12
    ARUCO = _aruco.Dictionary_ARUCO
    ARUCO_MIP_25h7 = _aruco.Dictionary_ARUCO_MIP_25h7
    ARUCO_MIP_16h3 = _aruco.Dictionary_ARUCO_MIP_16h3
    ARTAG = _aruco.Dictionary_ARTAG
    ARTOOLKITPLUS = _aruco.Dictionary_ARTOOLKITPLUS
    ARTOOLKITPLUSBCH = _aruco.Dictionary_ARTOOLKITPLUSBCH
    TAG16h5 = _aruco.Dictionary_TAG16h5
    TAG25h7 = _aruco.Dictionary_TAG25h7
    TAG25h9 = _aruco.Dictionary_TAG25h9
    TAG36h11 = _aruco.Dictionary_TAG36h11
    TAG36h10 = _aruco.Dictionary_TAG36h10
    CHILITAGS = _aruco.Dictionary_CHILITAGS
    CUSTOM = _aruco.Dictionary_CUSTOM
    ALL_DICTS = _aruco.Dictionary_ALL_DICTS

    def _is(self, code: 'uint64_t') -> "bool":
        return _aruco.Dictionary__is(self, code)

    def getType(self) -> "aruco::Dictionary::DICT_TYPES":
        return _aruco.Dictionary_getType(self)

    def size(self) -> "uint64_t":
        return _aruco.Dictionary_size(self)

    def nbits(self) -> "uint32_t":
        return _aruco.Dictionary_nbits(self)

    def tau(self) -> "uint32_t":
        return _aruco.Dictionary_tau(self)

    def getName(self) -> "std::string":
        return _aruco.Dictionary_getName(self)

    def getMapCode(self) -> "std::map< uint64_t,uint16_t > const &":
        return _aruco.Dictionary_getMapCode(self)

    def at(self, code: 'uint64_t') -> "int":
        return _aruco.Dictionary_at(self, code)

    def getMarkerImage_id(self, id: 'int', bit_size: 'int', addWaterMark: 'bool'=True, enclosed_corners: 'bool'=False, printExternalWhiteBorder: 'bool'=False) -> "cv::Mat":
        return _aruco.Dictionary_getMarkerImage_id(self, id, bit_size, addWaterMark, enclosed_corners, printExternalWhiteBorder)

    def createMarkerMap(self, gridSize: 'cv::Size', MarkerSize: 'int', MarkerDistance: 'int', Ids: 'VectorInt', chess_board: 'bool'=False) -> "aruco::MarkerMap":
        return _aruco.Dictionary_createMarkerMap(self, gridSize, MarkerSize, MarkerDistance, Ids, chess_board)
    __swig_getmethods__["loadPredefined"] = lambda x: _aruco.Dictionary_loadPredefined
    if _newclass:
        loadPredefined = staticmethod(_aruco.Dictionary_loadPredefined)
    __swig_getmethods__["loadFromFile"] = lambda x: _aruco.Dictionary_loadFromFile
    if _newclass:
        loadFromFile = staticmethod(_aruco.Dictionary_loadFromFile)
    __swig_getmethods__["load"] = lambda x: _aruco.Dictionary_load
    if _newclass:
        load = staticmethod(_aruco.Dictionary_load)
    __swig_getmethods__["computeDictionaryDistance"] = lambda x: _aruco.Dictionary_computeDictionaryDistance
    if _newclass:
        computeDictionaryDistance = staticmethod(_aruco.Dictionary_computeDictionaryDistance)
    __swig_getmethods__["getTypeFromString"] = lambda x: _aruco.Dictionary_getTypeFromString
    if _newclass:
        getTypeFromString = staticmethod(_aruco.Dictionary_getTypeFromString)
    __swig_getmethods__["getTypeString"] = lambda x: _aruco.Dictionary_getTypeString
    if _newclass:
        getTypeString = staticmethod(_aruco.Dictionary_getTypeString)
    __swig_getmethods__["isPredefinedDictinaryString"] = lambda x: _aruco.Dictionary_isPredefinedDictinaryString
    if _newclass:
        isPredefinedDictinaryString = staticmethod(_aruco.Dictionary_isPredefinedDictinaryString)
    __swig_getmethods__["getDicTypes"] = lambda x: _aruco.Dictionary_getDicTypes
    if _newclass:
        getDicTypes = staticmethod(_aruco.Dictionary_getDicTypes)

    def __init__(self):
        this = _aruco.new_Dictionary()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_Dictionary
    __del__ = lambda self: None
Dictionary_swigregister = _aruco.Dictionary_swigregister
Dictionary_swigregister(Dictionary)

def Dictionary_loadPredefined(*args) -> "aruco::Dictionary":
    return _aruco.Dictionary_loadPredefined(*args)
Dictionary_loadPredefined = _aruco.Dictionary_loadPredefined

def Dictionary_loadFromFile(path: 'std::string') -> "aruco::Dictionary":
    return _aruco.Dictionary_loadFromFile(path)
Dictionary_loadFromFile = _aruco.Dictionary_loadFromFile

def Dictionary_load(info: 'std::string') -> "aruco::Dictionary":
    return _aruco.Dictionary_load(info)
Dictionary_load = _aruco.Dictionary_load

def Dictionary_computeDictionaryDistance(d: 'Dictionary') -> "uint64_t":
    return _aruco.Dictionary_computeDictionaryDistance(d)
Dictionary_computeDictionaryDistance = _aruco.Dictionary_computeDictionaryDistance

def Dictionary_getTypeFromString(str: 'std::string') -> "aruco::Dictionary::DICT_TYPES":
    return _aruco.Dictionary_getTypeFromString(str)
Dictionary_getTypeFromString = _aruco.Dictionary_getTypeFromString

def Dictionary_getTypeString(t: 'aruco::Dictionary::DICT_TYPES') -> "std::string":
    return _aruco.Dictionary_getTypeString(t)
Dictionary_getTypeString = _aruco.Dictionary_getTypeString

def Dictionary_isPredefinedDictinaryString(str: 'std::string') -> "bool":
    return _aruco.Dictionary_isPredefinedDictinaryString(str)
Dictionary_isPredefinedDictinaryString = _aruco.Dictionary_isPredefinedDictinaryString

def Dictionary_getDicTypes() -> "std::vector< std::string,std::allocator< std::string > >":
    return _aruco.Dictionary_getDicTypes()
Dictionary_getDicTypes = _aruco.Dictionary_getDicTypes

class Point2fVec(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point2fVec, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Point2fVec, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _aruco.Point2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _aruco.Point2fVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _aruco.Point2fVec___bool__(self)

    def __len__(self) -> "std::vector< cv::Point2f >::size_type":
        return _aruco.Point2fVec___len__(self)

    def __getslice__(self, i: 'std::vector< cv::Point2f >::difference_type', j: 'std::vector< cv::Point2f >::difference_type') -> "std::vector< cv::Point2f,std::allocator< cv::Point2f > > *":
        return _aruco.Point2fVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _aruco.Point2fVec___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< cv::Point2f >::difference_type', j: 'std::vector< cv::Point2f >::difference_type') -> "void":
        return _aruco.Point2fVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _aruco.Point2fVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< cv::Point2f >::value_type const &":
        return _aruco.Point2fVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _aruco.Point2fVec___setitem__(self, *args)

    def pop(self) -> "std::vector< cv::Point2f >::value_type":
        return _aruco.Point2fVec_pop(self)

    def append(self, x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _aruco.Point2fVec_append(self, x)

    def empty(self) -> "bool":
        return _aruco.Point2fVec_empty(self)

    def size(self) -> "std::vector< cv::Point2f >::size_type":
        return _aruco.Point2fVec_size(self)

    def swap(self, v: 'Point2fVec') -> "void":
        return _aruco.Point2fVec_swap(self, v)

    def begin(self) -> "std::vector< cv::Point2f >::iterator":
        return _aruco.Point2fVec_begin(self)

    def end(self) -> "std::vector< cv::Point2f >::iterator":
        return _aruco.Point2fVec_end(self)

    def rbegin(self) -> "std::vector< cv::Point2f >::reverse_iterator":
        return _aruco.Point2fVec_rbegin(self)

    def rend(self) -> "std::vector< cv::Point2f >::reverse_iterator":
        return _aruco.Point2fVec_rend(self)

    def clear(self) -> "void":
        return _aruco.Point2fVec_clear(self)

    def get_allocator(self) -> "std::vector< cv::Point2f >::allocator_type":
        return _aruco.Point2fVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _aruco.Point2fVec_pop_back(self)

    def erase(self, *args) -> "std::vector< cv::Point2f >::iterator":
        return _aruco.Point2fVec_erase(self, *args)

    def __init__(self, *args):
        this = _aruco.new_Point2fVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _aruco.Point2fVec_push_back(self, x)

    def front(self) -> "std::vector< cv::Point2f >::value_type const &":
        return _aruco.Point2fVec_front(self)

    def back(self) -> "std::vector< cv::Point2f >::value_type const &":
        return _aruco.Point2fVec_back(self)

    def assign(self, n: 'std::vector< cv::Point2f >::size_type', x: 'std::vector< cv::Point2f >::value_type const &') -> "void":
        return _aruco.Point2fVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _aruco.Point2fVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _aruco.Point2fVec_insert(self, *args)

    def reserve(self, n: 'std::vector< cv::Point2f >::size_type') -> "void":
        return _aruco.Point2fVec_reserve(self, n)

    def capacity(self) -> "std::vector< cv::Point2f >::size_type":
        return _aruco.Point2fVec_capacity(self)
    __swig_destroy__ = _aruco.delete_Point2fVec
    __del__ = lambda self: None
Point2fVec_swigregister = _aruco.Point2fVec_swigregister
Point2fVec_swigregister(Point2fVec)

class MarkerVec(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerVec, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerVec, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _aruco.MarkerVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _aruco.MarkerVec___nonzero__(self)

    def __bool__(self) -> "bool":
        return _aruco.MarkerVec___bool__(self)

    def __len__(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _aruco.MarkerVec___len__(self)

    def __getslice__(self, i: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type', j: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type') -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > > *":
        return _aruco.MarkerVec___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _aruco.MarkerVec___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type', j: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::difference_type') -> "void":
        return _aruco.MarkerVec___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _aruco.MarkerVec___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _aruco.MarkerVec___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _aruco.MarkerVec___setitem__(self, *args)

    def pop(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type":
        return _aruco.MarkerVec_pop(self)

    def append(self, x: 'Marker') -> "void":
        return _aruco.MarkerVec_append(self, x)

    def empty(self) -> "bool":
        return _aruco.MarkerVec_empty(self)

    def size(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _aruco.MarkerVec_size(self)

    def swap(self, v: 'MarkerVec') -> "void":
        return _aruco.MarkerVec_swap(self, v)

    def begin(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _aruco.MarkerVec_begin(self)

    def end(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _aruco.MarkerVec_end(self)

    def rbegin(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::reverse_iterator":
        return _aruco.MarkerVec_rbegin(self)

    def rend(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::reverse_iterator":
        return _aruco.MarkerVec_rend(self)

    def clear(self) -> "void":
        return _aruco.MarkerVec_clear(self)

    def get_allocator(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::allocator_type":
        return _aruco.MarkerVec_get_allocator(self)

    def pop_back(self) -> "void":
        return _aruco.MarkerVec_pop_back(self)

    def erase(self, *args) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::iterator":
        return _aruco.MarkerVec_erase(self, *args)

    def __init__(self, *args):
        this = _aruco.new_MarkerVec(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'Marker') -> "void":
        return _aruco.MarkerVec_push_back(self, x)

    def front(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _aruco.MarkerVec_front(self)

    def back(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::value_type const &":
        return _aruco.MarkerVec_back(self)

    def assign(self, n: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type', x: 'Marker') -> "void":
        return _aruco.MarkerVec_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _aruco.MarkerVec_resize(self, *args)

    def insert(self, *args) -> "void":
        return _aruco.MarkerVec_insert(self, *args)

    def reserve(self, n: 'std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type') -> "void":
        return _aruco.MarkerVec_reserve(self, n)

    def capacity(self) -> "std::vector< aruco::Marker,std::allocator< aruco::Marker > >::size_type":
        return _aruco.MarkerVec_capacity(self)
    __swig_destroy__ = _aruco.delete_MarkerVec
    __del__ = lambda self: None
MarkerVec_swigregister = _aruco.MarkerVec_swigregister
MarkerVec_swigregister(MarkerVec)

class VectorMarker3DInfo(collections.MutableSequence):
    __swig_setmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorMarker3DInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [collections.MutableSequence]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorMarker3DInfo, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _aruco.VectorMarker3DInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _aruco.VectorMarker3DInfo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _aruco.VectorMarker3DInfo___bool__(self)

    def __len__(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _aruco.VectorMarker3DInfo___len__(self)

    def __getslice__(self, i: 'std::vector< aruco::Marker3DInfo >::difference_type', j: 'std::vector< aruco::Marker3DInfo >::difference_type') -> "std::vector< aruco::Marker3DInfo,std::allocator< aruco::Marker3DInfo > > *":
        return _aruco.VectorMarker3DInfo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _aruco.VectorMarker3DInfo___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< aruco::Marker3DInfo >::difference_type', j: 'std::vector< aruco::Marker3DInfo >::difference_type') -> "void":
        return _aruco.VectorMarker3DInfo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _aruco.VectorMarker3DInfo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _aruco.VectorMarker3DInfo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _aruco.VectorMarker3DInfo___setitem__(self, *args)

    def pop(self) -> "std::vector< aruco::Marker3DInfo >::value_type":
        return _aruco.VectorMarker3DInfo_pop(self)

    def append(self, x: 'Marker3DInfo') -> "void":
        return _aruco.VectorMarker3DInfo_append(self, x)

    def empty(self) -> "bool":
        return _aruco.VectorMarker3DInfo_empty(self)

    def size(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _aruco.VectorMarker3DInfo_size(self)

    def swap(self, v: 'VectorMarker3DInfo') -> "void":
        return _aruco.VectorMarker3DInfo_swap(self, v)

    def begin(self) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _aruco.VectorMarker3DInfo_begin(self)

    def end(self) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _aruco.VectorMarker3DInfo_end(self)

    def rbegin(self) -> "std::vector< aruco::Marker3DInfo >::reverse_iterator":
        return _aruco.VectorMarker3DInfo_rbegin(self)

    def rend(self) -> "std::vector< aruco::Marker3DInfo >::reverse_iterator":
        return _aruco.VectorMarker3DInfo_rend(self)

    def clear(self) -> "void":
        return _aruco.VectorMarker3DInfo_clear(self)

    def get_allocator(self) -> "std::vector< aruco::Marker3DInfo >::allocator_type":
        return _aruco.VectorMarker3DInfo_get_allocator(self)

    def pop_back(self) -> "void":
        return _aruco.VectorMarker3DInfo_pop_back(self)

    def erase(self, *args) -> "std::vector< aruco::Marker3DInfo >::iterator":
        return _aruco.VectorMarker3DInfo_erase(self, *args)

    def __init__(self, *args):
        this = _aruco.new_VectorMarker3DInfo(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x: 'Marker3DInfo') -> "void":
        return _aruco.VectorMarker3DInfo_push_back(self, x)

    def front(self) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _aruco.VectorMarker3DInfo_front(self)

    def back(self) -> "std::vector< aruco::Marker3DInfo >::value_type const &":
        return _aruco.VectorMarker3DInfo_back(self)

    def assign(self, n: 'std::vector< aruco::Marker3DInfo >::size_type', x: 'Marker3DInfo') -> "void":
        return _aruco.VectorMarker3DInfo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _aruco.VectorMarker3DInfo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _aruco.VectorMarker3DInfo_insert(self, *args)

    def reserve(self, n: 'std::vector< aruco::Marker3DInfo >::size_type') -> "void":
        return _aruco.VectorMarker3DInfo_reserve(self, n)

    def capacity(self) -> "std::vector< aruco::Marker3DInfo >::size_type":
        return _aruco.VectorMarker3DInfo_capacity(self)
    __swig_destroy__ = _aruco.delete_VectorMarker3DInfo
    __del__ = lambda self: None
VectorMarker3DInfo_swigregister = _aruco.VectorMarker3DInfo_swigregister
VectorMarker3DInfo_swigregister(VectorMarker3DInfo)

class Marker(Point2fVec):
    __swig_setmethods__ = {}
    for _s in [Point2fVec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Marker, name, value)
    __swig_getmethods__ = {}
    for _s in [Point2fVec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Marker, name)
    __repr__ = _swig_repr
    __swig_setmethods__["id"] = _aruco.Marker_id_set
    __swig_getmethods__["id"] = _aruco.Marker_id_get
    if _newclass:
        id = _swig_property(_aruco.Marker_id_get, _aruco.Marker_id_set)
    __swig_setmethods__["ssize"] = _aruco.Marker_ssize_set
    __swig_getmethods__["ssize"] = _aruco.Marker_ssize_get
    if _newclass:
        ssize = _swig_property(_aruco.Marker_ssize_get, _aruco.Marker_ssize_set)
    __swig_setmethods__["Rvec"] = _aruco.Marker_Rvec_set
    __swig_getmethods__["Rvec"] = _aruco.Marker_Rvec_get
    if _newclass:
        Rvec = _swig_property(_aruco.Marker_Rvec_get, _aruco.Marker_Rvec_set)
    __swig_setmethods__["Tvec"] = _aruco.Marker_Tvec_set
    __swig_getmethods__["Tvec"] = _aruco.Marker_Tvec_get
    if _newclass:
        Tvec = _swig_property(_aruco.Marker_Tvec_get, _aruco.Marker_Tvec_set)
    __swig_setmethods__["dict_info"] = _aruco.Marker_dict_info_set
    __swig_getmethods__["dict_info"] = _aruco.Marker_dict_info_get
    if _newclass:
        dict_info = _swig_property(_aruco.Marker_dict_info_get, _aruco.Marker_dict_info_set)

    def __init__(self, *args):
        this = _aruco.new_Marker(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_Marker
    __del__ = lambda self: None

    def isValid(self) -> "bool":
        return _aruco.Marker_isValid(self)

    def isPoseValid(self) -> "bool":
        return _aruco.Marker_isPoseValid(self)

    def draw(self, *args) -> "void":
        return _aruco.Marker_draw(self, *args)

    def calculateExtrinsics(self, *args) -> "void":
        return _aruco.Marker_calculateExtrinsics(self, *args)

    def glGetModelViewMatrix(self, modelview_matrix: 'double [16]') -> "void":
        return _aruco.Marker_glGetModelViewMatrix(self, modelview_matrix)

    def OgreGetPoseParameters(self, position: 'double [3]', orientation: 'double [4]') -> "void":
        return _aruco.Marker_OgreGetPoseParameters(self, position, orientation)

    def getCenter(self) -> "cv::Point2f":
        return _aruco.Marker_getCenter(self)

    def getPerimeter(self) -> "float":
        return _aruco.Marker_getPerimeter(self)

    def getArea(self) -> "float":
        return _aruco.Marker_getArea(self)

    def __eq__(self, m: 'Marker') -> "bool":
        return _aruco.Marker___eq__(self, m)

    def copyTo(self, m: 'Marker') -> "void":
        return _aruco.Marker_copyTo(self, m)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _aruco.Marker_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _aruco.Marker_fromStream(self, str)

    def get3DPoints(self, *args) -> "vector< cv::Point3f >":
        return _aruco.Marker_get3DPoints(self, *args)

    def __getitem__(self, i: 'int') -> "cv::Point2f":
        return _aruco.Marker___getitem__(self, i)

    def iterator(self):
        return VectorIterator(self)

Marker_swigregister = _aruco.Marker_swigregister
Marker_swigregister(Marker)


class VectorIterator(object):

    def __init__(self, pointerToVector):
        self.pointerToVector = pointerToVector
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1
        if self.index < len(self.pointerToVector):
            return self.pointerToVector[self.index]
        else:
            raise StopIteration

    def next(self):
        self.index += 1
        if self.index < len(self.pointerToVector):
            return self.pointerToVector[self.index]
        else:
            raise StopIteration


_aruco.DM_NORMAL_swigconstant(_aruco)
DM_NORMAL = _aruco.DM_NORMAL

_aruco.DM_FAST_swigconstant(_aruco)
DM_FAST = _aruco.DM_FAST

_aruco.DM_VIDEO_FAST_swigconstant(_aruco)
DM_VIDEO_FAST = _aruco.DM_VIDEO_FAST

_aruco.THRES_ADAPTIVE_swigconstant(_aruco)
THRES_ADAPTIVE = _aruco.THRES_ADAPTIVE

_aruco.THRES_AUTO_FIXED_swigconstant(_aruco)
THRES_AUTO_FIXED = _aruco.THRES_AUTO_FIXED
class Params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["maxThreads"] = _aruco.Params_maxThreads_set
    __swig_getmethods__["maxThreads"] = _aruco.Params_maxThreads_get
    if _newclass:
        maxThreads = _swig_property(_aruco.Params_maxThreads_get, _aruco.Params_maxThreads_set)
    __swig_setmethods__["borderDistThres"] = _aruco.Params_borderDistThres_set
    __swig_getmethods__["borderDistThres"] = _aruco.Params_borderDistThres_get
    if _newclass:
        borderDistThres = _swig_property(_aruco.Params_borderDistThres_get, _aruco.Params_borderDistThres_set)
    __swig_setmethods__["lowResMarkerSize"] = _aruco.Params_lowResMarkerSize_set
    __swig_getmethods__["lowResMarkerSize"] = _aruco.Params_lowResMarkerSize_get
    if _newclass:
        lowResMarkerSize = _swig_property(_aruco.Params_lowResMarkerSize_get, _aruco.Params_lowResMarkerSize_set)
    __swig_setmethods__["minSize"] = _aruco.Params_minSize_set
    __swig_getmethods__["minSize"] = _aruco.Params_minSize_get
    if _newclass:
        minSize = _swig_property(_aruco.Params_minSize_get, _aruco.Params_minSize_set)
    __swig_setmethods__["minSize_pix"] = _aruco.Params_minSize_pix_set
    __swig_getmethods__["minSize_pix"] = _aruco.Params_minSize_pix_get
    if _newclass:
        minSize_pix = _swig_property(_aruco.Params_minSize_pix_get, _aruco.Params_minSize_pix_set)
    __swig_setmethods__["enclosedMarker"] = _aruco.Params_enclosedMarker_set
    __swig_getmethods__["enclosedMarker"] = _aruco.Params_enclosedMarker_get
    if _newclass:
        enclosedMarker = _swig_property(_aruco.Params_enclosedMarker_get, _aruco.Params_enclosedMarker_set)

    def setThresholdMethod(self, method: 'aruco::ThresMethod', thresHold: 'int'=-1, wsize: 'int'=15, wsize_range: 'int'=0) -> "void":
        return _aruco.Params_setThresholdMethod(self, method, thresHold, wsize, wsize_range)
    __swig_setmethods__["_thresMethod"] = _aruco.Params__thresMethod_set
    __swig_getmethods__["_thresMethod"] = _aruco.Params__thresMethod_get
    if _newclass:
        _thresMethod = _swig_property(_aruco.Params__thresMethod_get, _aruco.Params__thresMethod_set)
    __swig_setmethods__["NAttemptsAutoThresFix"] = _aruco.Params_NAttemptsAutoThresFix_set
    __swig_getmethods__["NAttemptsAutoThresFix"] = _aruco.Params_NAttemptsAutoThresFix_get
    if _newclass:
        NAttemptsAutoThresFix = _swig_property(_aruco.Params_NAttemptsAutoThresFix_get, _aruco.Params_NAttemptsAutoThresFix_set)
    __swig_setmethods__["_AdaptiveThresWindowSize"] = _aruco.Params__AdaptiveThresWindowSize_set
    __swig_getmethods__["_AdaptiveThresWindowSize"] = _aruco.Params__AdaptiveThresWindowSize_get
    if _newclass:
        _AdaptiveThresWindowSize = _swig_property(_aruco.Params__AdaptiveThresWindowSize_get, _aruco.Params__AdaptiveThresWindowSize_set)
    __swig_setmethods__["_ThresHold"] = _aruco.Params__ThresHold_set
    __swig_getmethods__["_ThresHold"] = _aruco.Params__ThresHold_get
    if _newclass:
        _ThresHold = _swig_property(_aruco.Params__ThresHold_get, _aruco.Params__ThresHold_set)
    __swig_setmethods__["_AdaptiveThresWindowSize_range"] = _aruco.Params__AdaptiveThresWindowSize_range_set
    __swig_getmethods__["_AdaptiveThresWindowSize_range"] = _aruco.Params__AdaptiveThresWindowSize_range_get
    if _newclass:
        _AdaptiveThresWindowSize_range = _swig_property(_aruco.Params__AdaptiveThresWindowSize_range_get, _aruco.Params__AdaptiveThresWindowSize_range_set)
    __swig_setmethods__["_markerWarpPixSize"] = _aruco.Params__markerWarpPixSize_set
    __swig_getmethods__["_markerWarpPixSize"] = _aruco.Params__markerWarpPixSize_get
    if _newclass:
        _markerWarpPixSize = _swig_property(_aruco.Params__markerWarpPixSize_get, _aruco.Params__markerWarpPixSize_set)
    __swig_setmethods__["_autoSize"] = _aruco.Params__autoSize_set
    __swig_getmethods__["_autoSize"] = _aruco.Params__autoSize_get
    if _newclass:
        _autoSize = _swig_property(_aruco.Params__autoSize_get, _aruco.Params__autoSize_set)
    __swig_setmethods__["_ts"] = _aruco.Params__ts_set
    __swig_getmethods__["_ts"] = _aruco.Params__ts_get
    if _newclass:
        _ts = _swig_property(_aruco.Params__ts_get, _aruco.Params__ts_set)

    def setAutoSizeSpeedUp(self, v: 'bool', ts: 'float'=0.25) -> "void":
        return _aruco.Params_setAutoSizeSpeedUp(self, v, ts)

    def getAutoSizeSpeedUp(self) -> "bool":
        return _aruco.Params_getAutoSizeSpeedUp(self)
    __swig_setmethods__["pyrfactor"] = _aruco.Params_pyrfactor_set
    __swig_getmethods__["pyrfactor"] = _aruco.Params_pyrfactor_get
    if _newclass:
        pyrfactor = _swig_property(_aruco.Params_pyrfactor_get, _aruco.Params_pyrfactor_set)

    def __init__(self):
        this = _aruco.new_Params()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_Params
    __del__ = lambda self: None
Params_swigregister = _aruco.Params_swigregister
Params_swigregister(Params)

class MarkerCandidate(Marker):
    __swig_setmethods__ = {}
    for _s in [Marker]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerCandidate, name, value)
    __swig_getmethods__ = {}
    for _s in [Marker]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerCandidate, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _aruco.new_MarkerCandidate(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["contour"] = _aruco.MarkerCandidate_contour_set
    __swig_getmethods__["contour"] = _aruco.MarkerCandidate_contour_get
    if _newclass:
        contour = _swig_property(_aruco.MarkerCandidate_contour_get, _aruco.MarkerCandidate_contour_set)
    __swig_setmethods__["idx"] = _aruco.MarkerCandidate_idx_set
    __swig_getmethods__["idx"] = _aruco.MarkerCandidate_idx_get
    if _newclass:
        idx = _swig_property(_aruco.MarkerCandidate_idx_get, _aruco.MarkerCandidate_idx_set)
    __swig_destroy__ = _aruco.delete_MarkerCandidate
    __del__ = lambda self: None
MarkerCandidate_swigregister = _aruco.MarkerCandidate_swigregister
MarkerCandidate_swigregister(MarkerCandidate)

class MarkerDetector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerDetector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerDetector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _aruco.new_MarkerDetector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_MarkerDetector
    __del__ = lambda self: None

    def setDetectionMode(self, dm: 'aruco::DetectionMode', minMarkerSize: 'float'=0) -> "void":
        return _aruco.MarkerDetector_setDetectionMode(self, dm, minMarkerSize)

    def getDetectionMode(self) -> "aruco::DetectionMode":
        return _aruco.MarkerDetector_getDetectionMode(self)

    def detect(self, *args) -> "void":
        return _aruco.MarkerDetector_detect(self, *args)

    def getParameters(self, *args) -> "aruco::Params &":
        return _aruco.MarkerDetector_getParameters(self, *args)

    def setDictionary(self, *args) -> "void":
        return _aruco.MarkerDetector_setDictionary(self, *args)

    def getThresholdedImage(self, idx: 'uint32_t'=0) -> "cv::Mat":
        return _aruco.MarkerDetector_getThresholdedImage(self, idx)

    def setMarkerLabeler(self, detector: 'cv::Ptr< aruco::MarkerLabeler >') -> "void":
        return _aruco.MarkerDetector_setMarkerLabeler(self, detector)

    def getMarkerLabeler(self) -> "cv::Ptr< aruco::MarkerLabeler >":
        return _aruco.MarkerDetector_getMarkerLabeler(self)

    def getCandidates(self) -> "std::vector< std::vector< cv::Point2f,std::allocator< cv::Point2f > >,std::allocator< std::vector< cv::Point2f,std::allocator< cv::Point2f > > > >":
        return _aruco.MarkerDetector_getCandidates(self)

    def warp(self, arg2: 'cv::Mat &', out: 'cv::Mat &', size: 'cv::Size', points: 'Point2fVec') -> "bool":
        return _aruco.MarkerDetector_warp(self, arg2, out, size, points)
MarkerDetector_swigregister = _aruco.MarkerDetector_swigregister
MarkerDetector_swigregister(MarkerDetector)

class MarkerLabeler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerLabeler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerLabeler, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["create"] = lambda x: _aruco.MarkerLabeler_create
    if _newclass:
        create = staticmethod(_aruco.MarkerLabeler_create)

    def detect(self, arg2: 'cv::Mat const &', marker_id: 'int &', nRotations: 'int &', additionalInfo: 'std::string &') -> "bool":
        return _aruco.MarkerLabeler_detect(self, arg2, marker_id, nRotations, additionalInfo)

    def getBestInputSize(self) -> "int":
        return _aruco.MarkerLabeler_getBestInputSize(self)

    def getNSubdivisions(self) -> "int":
        return _aruco.MarkerLabeler_getNSubdivisions(self)

    def getName(self) -> "std::string":
        return _aruco.MarkerLabeler_getName(self)
    __swig_destroy__ = _aruco.delete_MarkerLabeler
    __del__ = lambda self: None
MarkerLabeler_swigregister = _aruco.MarkerLabeler_swigregister
MarkerLabeler_swigregister(MarkerLabeler)

def MarkerLabeler_create(*args) -> "cv::Ptr< aruco::MarkerLabeler >":
    return _aruco.MarkerLabeler_create(*args)
MarkerLabeler_create = _aruco.MarkerLabeler_create

class Marker3DInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Marker3DInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Marker3DInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["points"] = _aruco.Marker3DInfo_points_set
    __swig_getmethods__["points"] = _aruco.Marker3DInfo_points_get
    if _newclass:
        points = _swig_property(_aruco.Marker3DInfo_points_get, _aruco.Marker3DInfo_points_set)
    __swig_setmethods__["id"] = _aruco.Marker3DInfo_id_set
    __swig_getmethods__["id"] = _aruco.Marker3DInfo_id_get
    if _newclass:
        id = _swig_property(_aruco.Marker3DInfo_id_get, _aruco.Marker3DInfo_id_set)

    def __init__(self, *args):
        this = _aruco.new_Marker3DInfo(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __eq__(self, MI: 'Marker3DInfo') -> "bool":
        return _aruco.Marker3DInfo___eq__(self, MI)

    def getMarkerSize(self) -> "float":
        return _aruco.Marker3DInfo_getMarkerSize(self)

    def at(self, idx: 'size_t') -> "cv::Point3f":
        return _aruco.Marker3DInfo_at(self, idx)

    def push_back(self, p: 'cv::Point3f const &') -> "void":
        return _aruco.Marker3DInfo_push_back(self, p)

    def size(self) -> "size_t":
        return _aruco.Marker3DInfo_size(self)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _aruco.Marker3DInfo_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _aruco.Marker3DInfo_fromStream(self, str)
    __swig_destroy__ = _aruco.delete_Marker3DInfo
    __del__ = lambda self: None
Marker3DInfo_swigregister = _aruco.Marker3DInfo_swigregister
Marker3DInfo_swigregister(Marker3DInfo)

class MarkerMap(VectorMarker3DInfo):
    __swig_setmethods__ = {}
    for _s in [VectorMarker3DInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerMap, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorMarker3DInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _aruco.new_MarkerMap(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def isExpressedInMeters(self) -> "bool":
        return _aruco.MarkerMap_isExpressedInMeters(self)

    def isExpressedInPixels(self) -> "bool":
        return _aruco.MarkerMap_isExpressedInPixels(self)

    def convertToMeters(self, markerSize: 'float') -> "aruco::MarkerMap":
        return _aruco.MarkerMap_convertToMeters(self, markerSize)

    def getIndices(self, markers: 'vector< aruco::Marker > const &') -> "std::vector< int,std::allocator< int > >":
        return _aruco.MarkerMap_getIndices(self, markers)

    def getMarker3DInfo(self, id: 'int') -> "aruco::Marker3DInfo const &":
        return _aruco.MarkerMap_getMarker3DInfo(self, id)

    def getIndexOfMarkerId(self, id: 'int') -> "int":
        return _aruco.MarkerMap_getIndexOfMarkerId(self, id)

    def getIdList(self, ids: 'vector< int > &', append: 'bool'=True) -> "void":
        return _aruco.MarkerMap_getIdList(self, ids, append)

    def getImage(self, METER2PIX: 'float'=0) -> "cv::Mat":
        return _aruco.MarkerMap_getImage(self, METER2PIX)

    def saveToFile(self, sfile: 'std::string') -> "void":
        return _aruco.MarkerMap_saveToFile(self, sfile)

    def readFromFile(self, sfile: 'std::string') -> "void":
        return _aruco.MarkerMap_readFromFile(self, sfile)

    def calculateExtrinsics(self, markers: 'MarkerVec', markerSize: 'float', CameraMatrix: 'cv::Mat', Distorsion: 'cv::Mat') -> "std::pair< cv::Mat,cv::Mat >":
        return _aruco.MarkerMap_calculateExtrinsics(self, markers, markerSize, CameraMatrix, Distorsion)

    def getDictionary(self) -> "std::string":
        return _aruco.MarkerMap_getDictionary(self)
    NONE = _aruco.MarkerMap_NONE
    PIX = _aruco.MarkerMap_PIX
    METERS = _aruco.MarkerMap_METERS

    def setDictionary(self, d: 'std::string') -> "void":
        return _aruco.MarkerMap_setDictionary(self, d)
    __swig_setmethods__["mInfoType"] = _aruco.MarkerMap_mInfoType_set
    __swig_getmethods__["mInfoType"] = _aruco.MarkerMap_mInfoType_get
    if _newclass:
        mInfoType = _swig_property(_aruco.MarkerMap_mInfoType_get, _aruco.MarkerMap_mInfoType_set)

    def toStream(self, str: 'std::ostream &') -> "void":
        return _aruco.MarkerMap_toStream(self, str)

    def fromStream(self, str: 'std::istream &') -> "void":
        return _aruco.MarkerMap_fromStream(self, str)
    __swig_destroy__ = _aruco.delete_MarkerMap
    __del__ = lambda self: None
MarkerMap_swigregister = _aruco.MarkerMap_swigregister
MarkerMap_swigregister(MarkerMap)

class MarkerPoseTracker(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerPoseTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerPoseTracker, name)
    __repr__ = _swig_repr

    def estimatePose(self, m: 'Marker', cam_params: 'CameraParameters', markerSize: 'float', minErrorRatio: 'float'=4) -> "bool":
        return _aruco.MarkerPoseTracker_estimatePose(self, m, cam_params, markerSize, minErrorRatio)

    def getRTMatrix(self) -> "cv::Mat":
        return _aruco.MarkerPoseTracker_getRTMatrix(self)

    def getRvec(self) -> "cv::Mat const":
        return _aruco.MarkerPoseTracker_getRvec(self)

    def getTvec(self) -> "cv::Mat const":
        return _aruco.MarkerPoseTracker_getTvec(self)

    def __init__(self):
        this = _aruco.new_MarkerPoseTracker()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_MarkerPoseTracker
    __del__ = lambda self: None
MarkerPoseTracker_swigregister = _aruco.MarkerPoseTracker_swigregister
MarkerPoseTracker_swigregister(MarkerPoseTracker)

class MarkerMapPoseTracker(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MarkerMapPoseTracker, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MarkerMapPoseTracker, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _aruco.new_MarkerMapPoseTracker()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setParams(self, cam_params: 'CameraParameters', msconf: 'MarkerMap', markerSize: 'float'=-1) -> "void":
        return _aruco.MarkerMapPoseTracker_setParams(self, cam_params, msconf, markerSize)

    def isValid(self) -> "bool":
        return _aruco.MarkerMapPoseTracker_isValid(self)

    def reset(self) -> "void":
        return _aruco.MarkerMapPoseTracker_reset(self)

    def estimatePose(self, v_m: 'MarkerVec') -> "bool":
        return _aruco.MarkerMapPoseTracker_estimatePose(self, v_m)

    def getRTMatrix(self) -> "cv::Mat":
        return _aruco.MarkerMapPoseTracker_getRTMatrix(self)

    def getRvec(self) -> "cv::Mat const":
        return _aruco.MarkerMapPoseTracker_getRvec(self)

    def getTvec(self) -> "cv::Mat const":
        return _aruco.MarkerMapPoseTracker_getTvec(self)
    __swig_destroy__ = _aruco.delete_MarkerMapPoseTracker
    __del__ = lambda self: None
MarkerMapPoseTracker_swigregister = _aruco.MarkerMapPoseTracker_swigregister
MarkerMapPoseTracker_swigregister(MarkerMapPoseTracker)

class DictionaryBased(MarkerLabeler):
    __swig_setmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictionaryBased, name, value)
    __swig_getmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DictionaryBased, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _aruco.delete_DictionaryBased
    __del__ = lambda self: None

    def setParams(self, dic: 'Dictionary', max_correction_rate: 'float') -> "void":
        return _aruco.DictionaryBased_setParams(self, dic, max_correction_rate)

    def detect(self, arg2: 'cv::Mat const &', marker_id: 'int &', nRotations: 'int &', additionalInfo: 'std::string &') -> "bool":
        return _aruco.DictionaryBased_detect(self, arg2, marker_id, nRotations, additionalInfo)

    def getName(self) -> "std::string":
        return _aruco.DictionaryBased_getName(self)

    def getNSubdivisions(self) -> "int":
        return _aruco.DictionaryBased_getNSubdivisions(self)

    def __init__(self):
        this = _aruco.new_DictionaryBased()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
DictionaryBased_swigregister = _aruco.DictionaryBased_swigregister
DictionaryBased_swigregister(DictionaryBased)

class SVMMarkers(MarkerLabeler):
    __swig_setmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVMMarkers, name, value)
    __swig_getmethods__ = {}
    for _s in [MarkerLabeler]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVMMarkers, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _aruco.new_SVMMarkers()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_SVMMarkers
    __del__ = lambda self: None

    def getName(self) -> "std::string":
        return _aruco.SVMMarkers_getName(self)

    def load(self, *args) -> "bool":
        return _aruco.SVMMarkers_load(self, *args)

    def detect(self, arg2: 'cv::Mat const &', marker_id: 'int &', nRotations: 'int &', additionalInfo: 'std::string &') -> "bool":
        return _aruco.SVMMarkers_detect(self, arg2, marker_id, nRotations, additionalInfo)

    def getBestInputSize(self) -> "int":
        return _aruco.SVMMarkers_getBestInputSize(self)
SVMMarkers_swigregister = _aruco.SVMMarkers_swigregister
SVMMarkers_swigregister(SVMMarkers)

class ScopeTimer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScopeTimer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScopeTimer, name)
    __repr__ = _swig_repr
    __swig_setmethods__["begin"] = _aruco.ScopeTimer_begin_set
    __swig_getmethods__["begin"] = _aruco.ScopeTimer_begin_get
    if _newclass:
        begin = _swig_property(_aruco.ScopeTimer_begin_get, _aruco.ScopeTimer_begin_set)
    __swig_setmethods__["end"] = _aruco.ScopeTimer_end_set
    __swig_getmethods__["end"] = _aruco.ScopeTimer_end_get
    if _newclass:
        end = _swig_property(_aruco.ScopeTimer_end_get, _aruco.ScopeTimer_end_set)
    __swig_setmethods__["name"] = _aruco.ScopeTimer_name_set
    __swig_getmethods__["name"] = _aruco.ScopeTimer_name_get
    if _newclass:
        name = _swig_property(_aruco.ScopeTimer_name_get, _aruco.ScopeTimer_name_set)
    __swig_setmethods__["use"] = _aruco.ScopeTimer_use_set
    __swig_getmethods__["use"] = _aruco.ScopeTimer_use_get
    if _newclass:
        use = _swig_property(_aruco.ScopeTimer_use_get, _aruco.ScopeTimer_use_set)
    NSEC = _aruco.ScopeTimer_NSEC
    MSEC = _aruco.ScopeTimer_MSEC
    SEC = _aruco.ScopeTimer_SEC
    __swig_setmethods__["sc"] = _aruco.ScopeTimer_sc_set
    __swig_getmethods__["sc"] = _aruco.ScopeTimer_sc_get
    if _newclass:
        sc = _swig_property(_aruco.ScopeTimer_sc_get, _aruco.ScopeTimer_sc_set)

    def __init__(self, *args):
        this = _aruco.new_ScopeTimer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _aruco.delete_ScopeTimer
    __del__ = lambda self: None
ScopeTimer_swigregister = _aruco.ScopeTimer_swigregister
ScopeTimer_swigregister(ScopeTimer)

class ScopedTimerEvents(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScopedTimerEvents, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScopedTimerEvents, name)
    __repr__ = _swig_repr
    NSEC = _aruco.ScopedTimerEvents_NSEC
    MSEC = _aruco.ScopedTimerEvents_MSEC
    SEC = _aruco.ScopedTimerEvents_SEC
    __swig_setmethods__["sc"] = _aruco.ScopedTimerEvents_sc_set
    __swig_getmethods__["sc"] = _aruco.ScopedTimerEvents_sc_get
    if _newclass:
        sc = _swig_property(_aruco.ScopedTimerEvents_sc_get, _aruco.ScopedTimerEvents_sc_set)
    __swig_setmethods__["vtimes"] = _aruco.ScopedTimerEvents_vtimes_set
    __swig_getmethods__["vtimes"] = _aruco.ScopedTimerEvents_vtimes_get
    if _newclass:
        vtimes = _swig_property(_aruco.ScopedTimerEvents_vtimes_get, _aruco.ScopedTimerEvents_vtimes_set)
    __swig_setmethods__["names"] = _aruco.ScopedTimerEvents_names_set
    __swig_getmethods__["names"] = _aruco.ScopedTimerEvents_names_get
    if _newclass:
        names = _swig_property(_aruco.ScopedTimerEvents_names_get, _aruco.ScopedTimerEvents_names_set)
    __swig_setmethods__["_name"] = _aruco.ScopedTimerEvents__name_set
    __swig_getmethods__["_name"] = _aruco.ScopedTimerEvents__name_get
    if _newclass:
        _name = _swig_property(_aruco.ScopedTimerEvents__name_get, _aruco.ScopedTimerEvents__name_set)

    def __init__(self, *args):
        this = _aruco.new_ScopedTimerEvents(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add(self, name: 'std::string') -> "void":
        return _aruco.ScopedTimerEvents_add(self, name)

    def addspaces(self, str: 'std::vector< std::string,std::allocator< std::string > > &') -> "void":
        return _aruco.ScopedTimerEvents_addspaces(self, str)
    __swig_destroy__ = _aruco.delete_ScopedTimerEvents
    __del__ = lambda self: None
ScopedTimerEvents_swigregister = _aruco.ScopedTimerEvents_swigregister
ScopedTimerEvents_swigregister(ScopedTimerEvents)

class Timer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Timer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Timer, name)
    __repr__ = _swig_repr
    NSEC = _aruco.Timer_NSEC
    MSEC = _aruco.Timer_MSEC
    SEC = _aruco.Timer_SEC
    __swig_setmethods__["_s"] = _aruco.Timer__s_set
    __swig_getmethods__["_s"] = _aruco.Timer__s_get
    if _newclass:
        _s = _swig_property(_aruco.Timer__s_get, _aruco.Timer__s_set)
    __swig_setmethods__["sum"] = _aruco.Timer_sum_set
    __swig_getmethods__["sum"] = _aruco.Timer_sum_get
    if _newclass:
        sum = _swig_property(_aruco.Timer_sum_get, _aruco.Timer_sum_set)
    __swig_setmethods__["n"] = _aruco.Timer_n_set
    __swig_getmethods__["n"] = _aruco.Timer_n_get
    if _newclass:
        n = _swig_property(_aruco.Timer_n_get, _aruco.Timer_n_set)
    __swig_setmethods__["_name"] = _aruco.Timer__name_set
    __swig_getmethods__["_name"] = _aruco.Timer__name_get
    if _newclass:
        _name = _swig_property(_aruco.Timer__name_get, _aruco.Timer__name_set)

    def __init__(self, *args):
        this = _aruco.new_Timer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setName(self, name: 'std::string') -> "void":
        return _aruco.Timer_setName(self, name)

    def start(self) -> "void":
        return _aruco.Timer_start(self)

    def end(self) -> "void":
        return _aruco.Timer_end(self)

    def _print(self, *args) -> "void":
        return _aruco.Timer__print(self, *args)

    def getAverage(self, *args) -> "double":
        return _aruco.Timer_getAverage(self, *args)
    __swig_destroy__ = _aruco.delete_Timer
    __del__ = lambda self: None
Timer_swigregister = _aruco.Timer_swigregister
Timer_swigregister(Timer)

# This file is compatible with both classic and new-style classes.


