#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.excutils',
  description = 'Convenience facilities for managing exceptions.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20190220',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 (GPLv3)'],
  install_requires = ['cs.deco', 'cs.logutils', 'cs.py.func'],
  keywords = ['python2', 'python3'],
  long_description = 'Convenience facilities for managing exceptions.\n\n## Function `logexc(func)`\n\nDecorator to log exceptions and reraise.\n\n## Function `logexc_gen(genfunc)`\n\nDecorator to log exceptions and reraise for generators.\n\n## Function `LogExceptions(conceal=False)`\n\nWrapper of NoExceptions which reports exceptions and optionally\nsuppresses them.\n\n## Function `noexc(func)`\n\nDecorator to wrap a function which should never raise an exception.\nInstead, any raised exception is attempted to be logged.\n\nA significant side effect is of course that if the function raises an\nexception it now returns None.\nMy primary use case is actually to wrap logging functions,\nwhich I have had abort otherwise sensible code.\n\n## Function `noexc_gen(func)`\n\nDecorator to wrap a generator which should never raise an exception.\nInstead, any raised exception is attempted to be logged and iteration ends.\n\nMy primary use case is wrapping generators chained in a pipeline,\nas in cs.later.Later.pipeline.\n\n## Class `NoExceptions`\n\nA context manager to catch _all_ exceptions and log them.\nArguably this should be a bare try...except but that\'s syntacticly\nnoisy and separates the catch from the top.\nFor simple function calls return_exc_info() is probably better.\n\n## Function `return_exc_info(func, *args, **kwargs)`\n\nRun the supplied function and arguments.\nReturn `(func_return, None)`\nin the case of successful operation\nand `(None, exc_info)` in the case of an exception.\n\n`exc_info` is a 3-tuple of `(exc_type, exc_value, exc_traceback)`\nas returned by `sys.exc_info()`.\nIf you need to protect a whole suite and would rather not move it\ninto its own function, consider the NoExceptions context manager.\n\n## Function `returns_exc_info(func)`\n\nDecorator function to wrap functions whose exceptions should be caught,\nsuch as inside event loops or worker threads.\n\nIt causes a function to return `(func_return, None)`\nin the case of successful operation\nand `(None, exc_info)` in the case of an exception.\n\n`exc_info` is a 3-tuple of `(exc_type, exc_value, exc_traceback)`\nas returned by `sys.exc_info()`.\n\n## Function `safe_property(func)`\n\nSubstitute for @property which lets AttributeErrors escape as RuntimeErrors.\n\n## Function `transmute(exc_from, exc_to=None)`\n\nDecorator to transmute an inner exception to another exception type.\n\nThe motivating use case is properties in a class with a\n__getattr__ method; if some inner operation of the property\nfunction raises AttributeError then the property is bypassed\nin favour of __getattr__. Confusion ensues.\n\nIn principle this can be an issue with any exception raised\nfrom "deeper" in the call chain, which can be mistaken for a\n"shallow" exception raise by the function itself.\n\n## Function `unattributable(func)`\n\nDecorator to transmute AttributeError into a RuntimeError.\n\n## Function `unimplemented(func)`\n\nDecorator for stub methods that must be implemented by a stub class.',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.excutils'],
)
