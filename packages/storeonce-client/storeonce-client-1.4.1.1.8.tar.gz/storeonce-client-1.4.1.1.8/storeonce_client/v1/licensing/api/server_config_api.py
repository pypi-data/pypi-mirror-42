# coding: utf-8

"""
    (C) Copyright 2018-2019 Hewlett Packard Enterprise Development LP

    Licensing

    unused  # noqa: E501

    Component version: 6.0.31-SNAPSHOT
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class ServerConfigApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def disconnect_server(self, **kwargs):  # noqa: E501
        """Disconnects from the server and releases all tokens.  # noqa: E501

        Attempts to disconnect from the license server. All license tokens are returned to the server and the server configuration data is deleted.If the license server is offline, tokens cannot be returned and the disconnect request will abort.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.disconnect_server(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.disconnect_server_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disconnect_server_with_http_info(**kwargs)  # noqa: E501
            return data

    def disconnect_server_with_http_info(self, **kwargs):  # noqa: E501
        """Disconnects from the server and releases all tokens.  # noqa: E501

        Attempts to disconnect from the license server. All license tokens are returned to the server and the server configuration data is deleted.If the license server is offline, tokens cannot be returned and the disconnect request will abort.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_=True
        >>> thread = api.disconnect_server_with_http_info(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disconnect_server" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/licensing/server', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def force_disconnect_server(self, **kwargs):  # noqa: E501
        """Force disconnects from the server and releases all tokens.  # noqa: E501

        If the license server is offline, a normal disconnect will abort. This forces the disconnection by destroying any license tokens currently leased to the client.Those token will be unavailable until they expire at which point then will automatically be added back to the server pool. Cloud detach licenses do not expire so will not be visable on the client or server after this point. This will not affect cloud stores as the license key is embedded in the store.This operation should not be used unless absolutely needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.force_disconnect_server(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: StoreonceLicenseServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.force_disconnect_server_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.force_disconnect_server_with_http_info(**kwargs)  # noqa: E501
            return data

    def force_disconnect_server_with_http_info(self, **kwargs):  # noqa: E501
        """Force disconnects from the server and releases all tokens.  # noqa: E501

        If the license server is offline, a normal disconnect will abort. This forces the disconnection by destroying any license tokens currently leased to the client.Those token will be unavailable until they expire at which point then will automatically be added back to the server pool. Cloud detach licenses do not expire so will not be visable on the client or server after this point. This will not affect cloud stores as the license key is embedded in the store.This operation should not be used unless absolutely needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_=True
        >>> thread = api.force_disconnect_server_with_http_info(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: StoreonceLicenseServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method force_disconnect_server" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/licensing/server/force', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoreonceLicenseServer',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_license_server(self, **kwargs):  # noqa: E501
        """Returns the current primary server configuration and its status data.  # noqa: E501

        Contains server status and the base license id (if base license installed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_license_server(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: StoreonceLicenseServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.get_license_server_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_license_server_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_license_server_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the current primary server configuration and its status data.  # noqa: E501

        Contains server status and the base license id (if base license installed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_=True
        >>> thread = api.get_license_server_with_http_info(async_=True)
        >>> result = thread.get()

        :param async_ bool
        :return: StoreonceLicenseServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_license_server" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/licensing/server', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoreonceLicenseServer',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_server(self, body, **kwargs):  # noqa: E501
        """Sets the current primary server configuration  # noqa: E501

        On initial configuration client will connect to server and attempt to checkout the minimum license set.On server change, a check will be made to ensure the new server has sufficient licenses before the clientwill release existing tokens, connect to the new server and reaquire its license token set.If the enabled flag is set false, then the server is disconnected and licenses released.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.modify_server(body, async_=True)
        >>> result = thread.get()

        :param async_ bool
        :param StoreonceLicenseServer body: The server config to be applied (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_'):
            return self.modify_server_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_server_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def modify_server_with_http_info(self, body, **kwargs):  # noqa: E501
        """Sets the current primary server configuration  # noqa: E501

        On initial configuration client will connect to server and attempt to checkout the minimum license set.On server change, a check will be made to ensure the new server has sufficient licenses before the clientwill release existing tokens, connect to the new server and reaquire its license token set.If the enabled flag is set false, then the server is disconnected and licenses released.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_=True
        >>> thread = api.modify_server_with_http_info(body, async_=True)
        >>> result = thread.get()

        :param async_ bool
        :param StoreonceLicenseServer body: The server config to be applied (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'oauth']  # noqa: E501

        return self.api_client.call_api(
            '/licensing/server', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
