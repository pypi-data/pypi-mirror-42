///////////////////////////////////////////////////////////////////////
//
//  {{ quantum.project.name|upper }} IMAGE BUILD PIPELINE
//
///////////////////////////////////////////////////////////////////////
{%- if quantum.ci.branches %}
def branches = [
  {%- for branch in quantum.ci.branches %}
  '{{ branch.name }}': [
    {%- if branch.environment %}
    environment: '{{ branch.environment }}',
    {%- else %}
    environment: null,
    {%- endif %}
    {%- if branch.deployment %}
    deployment: '{{ branch.deployment }}',
    {%- else %}
    deployment: null,
    {%- endif %}
    {%- if branch.always_deploy %}
    always_deploy: true,
    {%- else %}
    always_deploy: false,
    {%- endif %}
    {%- if branch.always_publish %}
    always_publish: true
    {%- else %}
    always_publish: false
    {%- endif %}
  ]{% if not loop.last %},{% endif %}
  {%- endfor %}
]
{%- else %}
def branches = [:]
{%- endif %}
def build_credentials = []
def changed_files
def commit_tag
def commit_hash
def config
def image
{%- if DOCKER_IMAGE_QUALNAME is defined %}
def image_name = '{{ DOCKER_IMAGE_QUALNAME }}'
{%- else %}
def image_name = '{{ quantum.docker.repository }}'
{%- endif %}
def image_tag
def registries = [
  default: [
    {%- if quantum.ci.container_registries.default.url not in ('docker.io', None) %}
    url: '{{ quantum.ci.container_registries.default.url }}',
    {%- else %}
    url: null,
    {%- endif %}
    {%- if quantum.ci.container_registries.default.secret %}
    credentialsId: '{{ quantum.ci.container_registries.default.secret }}'
    {%- else %}
    credentialsId: null
    {%- endif %}
  ],
  base: [
    {%- if quantum.ci.container_registries.base.url not in ('docker.io', None) %}
    url: '{{ quantum.ci.container_registries.base.url }}',
    {%- else %}
    url: null,
    {%- endif %}
    {%- if quantum.ci.container_registries.base.secret %}
    credentialsId: '{{ quantum.ci.container_registries.base.secret }}'
    {%- else %}
    credentialsId: null
    {%- endif %}
  ],
  build: [
    {%- if quantum.ci.container_registries.build.url not in ('docker.io', None) %}
    url: '{{ quantum.ci.container_registries.build.url }}',
    {%- else %}
    url: null,
    {%- endif %}
    {%- if quantum.ci.container_registries.build.secret %}
    credentialsId: '{{ quantum.ci.container_registries.build.secret }}'
    {%- else %}
    credentialsId: null
    {%- endif %}
  ],
  publish: [
    {%- if quantum.ci.container_registries.publish.url not in ('docker.io', None) %}
    url: '{{ quantum.ci.container_registries.publish.url }}',
    {%- else %}
    url: null,
    {%- endif %}
    {%- if quantum.ci.container_registries.publish.secret %}
    credentialsId: '{{ quantum.ci.container_registries.publish.secret }}'
    {%- else %}
    credentialsId: null
    {%- endif %}
  ]
]
def tags = []


pipeline {
  agent {
    label 'docker'
  }

  stages {
    stage('Setup') {
      steps {
        script {
          config = branches[env.GIT_BRANCH]
          changed_files = sh(
            script: 'git diff --name-only HEAD^1',
            returnStdout: true
          ).trim().tokenize('\n')
          for (i in changed_files) {
            echo("Detected change in ${i}")
          }

          // Ensure that all tags are fetched and assign it to a variable. Note
          // that if the branch contains multiple tags, the last one (as returned
          // by git tag -l) will be used.
          commit_tag = sh(
            returnStdout: true,
            script: "git tag -l --points-at HEAD | tail -1"
          ).trim()
          if (commit_tag) {
            echo("Commit tag is: ${commit_tag}")
          }
          commit_hash = sh(
            returnStdout: true,
            script: "git rev-parse --short HEAD | tr -d '\n'"
          ).trim()
          echo("Commit hash is: ${commit_hash}")
        }
      }
    } // End Setup stage

    stage('Lint') {
      steps {
        script {
          docker.image('hadolint/hadolint:latest-debian').inside() {
            sh("hadolint Dockerfile")
          }
        }
      }
    } // End Lint stage

    stage('Build') {
      steps {
        script {
          {%- if quantum.project.type != 'container-image' %}
          // Ensure that the base image is up-to-date.
          withDockerRegistry(registries.base) {
            image_base = docker.image('{{ quantum.docker.base_image }}')
            image_base.pull()
          }
          {%- endif %}
          {%- for secret in quantum.ci.mounted_secrets %}
          {%- if secret.kind == 'ssh' %}
          build_credentials += sshUserPrivateKey(
            credentialsId: '{{ secret.name }}',
            keyFileVariable: '{{ secret.name|safe_variable }}'
          )
          {%- else %}
          // WARNING: Secret '{{ secret.name }}' can not be injected
          // because its type ({{ secret.kind }}) is not supported
          {%- endif %}
          {%- endfor %}
          withCredentials(build_credentials) {
            {%- for secret in quantum.ci.mounted_secrets %}
            {%- if secret.kind == 'ssh' %}
            sh('cat ${{ secret.name|safe_variable }} > {{ secret.path }}')
            {%- endif %}
            {%- endfor %}

            // Put the Jenkins build identifier in the image
            // tag so that we can run concurrent builds.
            image = docker.build("${image_name}:${env.BUILD_ID}")
          }
        }
      }
    } // End Build stage

    stage('Publish') {
      when {
        expression {
          return (!!commit_tag) || (!!config && !!config.always_publish)
        }
      }
      steps {
        script {
          tags.add((!!commit_tag) ? commit_tag : commit_hash);
          tags.add('latest')
          withDockerRegistry(registries.publish) {
            for (int i = 0; i < tags.size(); i++) {
              image.push("${tags[i]}")
            }
          }
        }
      }
    } // End Publish stage
  }
}
