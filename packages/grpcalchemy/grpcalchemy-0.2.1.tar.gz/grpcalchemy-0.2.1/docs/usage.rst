=====
Usage
=====

To use gRPCAlchemy in a project:

.. code-block:: python

    from grpcalchemy.orm import Message, StringField
    from grpcalchemy import Server, Context

    app = Server('server')

    class HelloMessage(Message):
        __filename__ = 'hello'
        name = StringField()

    @app.register
    def test(request: HelloMessage, context: Context) -> HelloMessage:
        return HelloMessage(name=f'Hello {request.name}')

    if __name__ == '__main__':
        app.run()


Defining our Message
===================================

Any message which is used in RPC method must have a explicit schema. We can
use py files generated by proto files by the grpc_tools straightly. However
defining the schemas by our ORM can help to iron out bugs involving incorrect
types or missing fields, and also allow us to define utility methods on our message
in the same way that traditional ORMs do.

In our Tutorial Application we need to send several different types of
message. We will need to have a collection of **users**, so that we may
link posts to an individual. We also need to send our different types of
**posts** (eg: text, image and link) in the RPC method. To aid navigation of our
Tutorial Application, posts may have **tags** associated with them, so that the list of
posts shown to the user may be limited to posts that have been assigned a
specific tag. Finally, it would be nice if **comments** could be added to
posts. We'll start with **users**, as the other document models are slightly
more involved.

Users
-----

Just as if we were using a RPC Message with an ORM, we need to define
which fields a :class:`User` may have, and what types of data they might have:

.. code-block:: python

    class User(Message):
        email = StringField()
        first_name = StringField()
        last_name = StringField()

Posts, Comments and Tags
------------------------

Now we'll think about how to define the rest of the information. To associate the comments
with individual posts, We'd also need a link message to provide the
many-to-many relationship between posts and tags.

Posts
^^^^^

We can think of :class:`Post` as a base class, and :class:`TextPost`, :class:`ImagePost` and
:class:`LinkPost` as subclasses of :class:`Post`.

.. code-block:: python

    class Post(Message):
        title = StringField()
        author = ReferenceField(User)

    class TextPost(Post):
        content = StringField()

    class ImagePost(Post):
        image_path = StringField()

    class LinkPost(Post):
        link_url = StringField()

We are storing a reference to the author of the posts using a
:class:`~grpcalchemy.orm.ReferenceField` object. These are equal to use other
message types in RPC message.

Tags
^^^^

Now that we have our Post models figured out, how will we attach tags to them?
RPC message allows us to define lists of items natively. So, for both
efficiency and simplicity's sake, we'll define the tags as strings directly
within the post. Let's take a look at the code of our modified :class:`Post` class:

.. code-block:: python

    class Post(Message):
        title = StringField()
        author = ReferenceField(User)
        tags = ListField(StringField)

The :class:`~grpcalchemy.orm.ListField` object that is used to define a Post's tags
takes a field object as its first argument --- this means that you can have
lists of any type of field (including lists).

.. note:: We don't need to modify the specialized post types as they all
    inherit from :class:`Post`.

Comments
^^^^^^^^

A comment is typically associated with *one* post.utility methods,
in exactly the same way we do with regular documents:

.. code-block:: python

    class Comment(Message):
        content = StringField()
        name = StringField()

We can then define a list of comment documents in our post message:

.. code-block:: python

    class Post(Document):
        title = StringField()
        author = ReferenceField(User)
        tags = ListField(StringField)
        comments = ListField(Comment)

Defining our gRPC Method
===================================

The ``valid registered function`` must be with `explicit type hint <https://www.python.org/dev/peps/pep-0484/#type-definition-syntax>`_
to define the type of request and return value.

.. code-block:: python

    app = Server('hello')

    @app.register
    def test(request: HelloMessage, context: Context) -> HelloMessage: ...

The above code is equal to an RPC service with a method::

    syntax = "proto3";

    service hello {
        rpc test (HelloMessage) returns (HelloMessage) {
        }
    }


Using Blueprint to Construct Your Large Application
=========================================================

gRPCAlchemy uses a concept of blueprints for making gRPC services and
supporting common patterns within an application or across applications.
:any:`Blueprint` can greatly simplify how large applications work.

.. code-block:: python

    from grpcalchemy.orm import Message, StringField
    from grpcalchemy import Server, Context, Blueprint

    app = Server('server')

    first_blueprint = Blueprint('first_blueprint')

    class HelloMessage(Message):
        __filename__ = 'hello'
        name = StringField()

    @first_blueprint.register
    def test(request: HelloMessage, context: Context) -> HelloMessage:
        return HelloMessage(name=f'Hello {request.name}')

    if __name__ == '__main__':
        app.register_blueprint(first_blueprint)
        app.run()

