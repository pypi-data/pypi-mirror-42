/**
    This file is autogenerated
*/

  py::class_<rev::CANDigitalInput> candigitalinput(m, "CANDigitalInput");
  candigitalinput
      .def("get", &rev::CANDigitalInput::Get, release_gil())
      .def("enableLimitSwitch", &rev::CANDigitalInput::EnableLimitSwitch, py::arg("enable"), release_gil())
      .def("isLimitSwitchEnabled", &rev::CANDigitalInput::IsLimitSwitchEnabled, release_gil())
  ;
  py::class_<rev::CANEncoder> canencoder(m, "CANEncoder");
  canencoder
      .def("getPosition", &rev::CANEncoder::GetPosition, release_gil())
      .def("getVelocity", &rev::CANEncoder::GetVelocity, release_gil())
      .def("setPosition", &rev::CANEncoder::SetPosition, py::arg("position"), release_gil())
      .def("setPositionConversionFactor", &rev::CANEncoder::SetPositionConversionFactor, py::arg("factor"), release_gil())
      .def("setVelocityConversionFactor", &rev::CANEncoder::SetVelocityConversionFactor, py::arg("factor"), release_gil())
      .def("getPositionConversionFactor", &rev::CANEncoder::GetPositionConversionFactor, release_gil())
      .def("getVelocityConversionFactor", &rev::CANEncoder::GetVelocityConversionFactor, release_gil())
  ;
  py::class_<rev::CANPIDController> canpidcontroller(m, "CANPIDController");
  canpidcontroller
      .def("setReference", &rev::CANPIDController::SetReference, py::arg("value"), py::arg("ctrl"), py::arg("pidSlot")=0, py::arg("arbFeedforward")=0, release_gil())
      .def("setP", &rev::CANPIDController::SetP, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setI", &rev::CANPIDController::SetI, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setD", &rev::CANPIDController::SetD, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setDFilter", &rev::CANPIDController::SetDFilter, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setFF", &rev::CANPIDController::SetFF, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setIZone", &rev::CANPIDController::SetIZone, py::arg("IZone"), py::arg("slotID")=0, release_gil())
      .def("setOutputRange", &rev::CANPIDController::SetOutputRange, py::arg("min"), py::arg("max"), py::arg("slotID")=0, release_gil())
      .def("getP", &rev::CANPIDController::GetP, py::arg("slotID")=0, release_gil())
      .def("getI", &rev::CANPIDController::GetI, py::arg("slotID")=0, release_gil())
      .def("getD", &rev::CANPIDController::GetD, py::arg("slotID")=0, release_gil())
      .def("getDFilter", &rev::CANPIDController::GetDFilter, py::arg("slotID")=0, release_gil())
      .def("getFF", &rev::CANPIDController::GetFF, py::arg("slotID")=0, release_gil())
      .def("getIZone", &rev::CANPIDController::GetIZone, py::arg("slotID")=0, release_gil())
      .def("getOutputMin", &rev::CANPIDController::GetOutputMin, py::arg("slotID")=0, release_gil())
      .def("getOutputMax", &rev::CANPIDController::GetOutputMax, py::arg("slotID")=0, release_gil())
      .def("setSmartMotionMaxVelocity", &rev::CANPIDController::SetSmartMotionMaxVelocity, py::arg("maxVel"), py::arg("slotID")=0, release_gil())
      .def("setSmartMotionMaxAccel", &rev::CANPIDController::SetSmartMotionMaxAccel, py::arg("maxAccel"), py::arg("slotID")=0, release_gil())
      .def("setSmartMotionMinOutputVelocity", &rev::CANPIDController::SetSmartMotionMinOutputVelocity, py::arg("minVel"), py::arg("slotID")=0, release_gil())
      .def("setSmartMotionAllowedClosedLoopError", &rev::CANPIDController::SetSmartMotionAllowedClosedLoopError, py::arg("allowedErr"), py::arg("slotID")=0, release_gil())
      .def("setSmartMotionAccelStrategy", &rev::CANPIDController::SetSmartMotionAccelStrategy, py::arg("accelStrategy"), py::arg("slotID")=0, release_gil())
      .def("getSmartMotionMaxVelocity", &rev::CANPIDController::GetSmartMotionMaxVelocity, py::arg("slotID")=0, release_gil())
      .def("getSmartMotionMaxAccel", &rev::CANPIDController::GetSmartMotionMaxAccel, py::arg("slotID")=0, release_gil())
      .def("getSmartMotionMinOutputVelocity", &rev::CANPIDController::GetSmartMotionMinOutputVelocity, py::arg("slotID")=0, release_gil())
      .def("getSmartMotionAllowedClosedLoopError", &rev::CANPIDController::GetSmartMotionAllowedClosedLoopError, py::arg("slotID")=0, release_gil())
      .def("getSmartMotionAccelStrategy", &rev::CANPIDController::GetSmartMotionAccelStrategy, py::arg("slotID")=0, release_gil())
      .def("setIMaxAccum", &rev::CANPIDController::SetIMaxAccum, py::arg("iMaxAccum"), py::arg("slotID")=0, release_gil())
      .def("getIMaxAccum", &rev::CANPIDController::GetIMaxAccum, py::arg("slotID")=0, release_gil())
      .def("setIAccum", &rev::CANPIDController::SetIAccum, py::arg("iAccum"), release_gil())
      .def("getIAccum", &rev::CANPIDController::GetIAccum, release_gil())
  ;
  py::class_<rev::CANSparkMaxLowLevel> cansparkmaxlowlevel(m, "CANSparkMaxLowLevel");
  cansparkmaxlowlevel
      .def("getFirmwareVersion", py::overload_cast<>(&rev::CANSparkMaxLowLevel::GetFirmwareVersion), release_gil())
      .def("getFirmwareString", &rev::CANSparkMaxLowLevel::GetFirmwareString, release_gil())
      .def("getSerialNumber", &rev::CANSparkMaxLowLevel::GetSerialNumber, release_gil())
      .def("getDeviceId", &rev::CANSparkMaxLowLevel::GetDeviceId, release_gil())
      .def("setMotorType", &rev::CANSparkMaxLowLevel::SetMotorType, py::arg("type"), release_gil())
      .def("getMotorType", &rev::CANSparkMaxLowLevel::GetMotorType, release_gil())
      .def("setPeriodicFramePeriod", &rev::CANSparkMaxLowLevel::SetPeriodicFramePeriod, py::arg("frame"), py::arg("periodMs"), release_gil())
      .def("getParameterType", &rev::CANSparkMaxLowLevel::GetParameterType, py::arg("parameterID"), release_gil())
      .def("setParameter", py::overload_cast<rev::CANSparkMaxLowLevel::ConfigParameter, double>(&rev::CANSparkMaxLowLevel::SetParameter), py::arg("parameterID"), py::arg("value"), release_gil())
      .def("setParameter", py::overload_cast<rev::CANSparkMaxLowLevel::ConfigParameter, uint32_t>(&rev::CANSparkMaxLowLevel::SetParameter), py::arg("parameterID"), py::arg("value"), release_gil())
      .def("setParameter", py::overload_cast<rev::CANSparkMaxLowLevel::ConfigParameter, int32_t>(&rev::CANSparkMaxLowLevel::SetParameter), py::arg("parameterID"), py::arg("value"), release_gil())
      .def("setParameter", py::overload_cast<rev::CANSparkMaxLowLevel::ConfigParameter, bool>(&rev::CANSparkMaxLowLevel::SetParameter), py::arg("parameterID"), py::arg("value"), release_gil())
      .def("setEncPosition", &rev::CANSparkMaxLowLevel::SetEncPosition, py::arg("value"), release_gil())
      .def("setIAccum", &rev::CANSparkMaxLowLevel::SetIAccum, py::arg("value"), release_gil())
      .def("restoreFactoryDefaults", &rev::CANSparkMaxLowLevel::RestoreFactoryDefaults, py::arg("persist")=false, release_gil())
  ;
  py::class_<rev::CANSparkMax, rev::CANSparkMaxLowLevel> cansparkmax(m, "CANSparkMax");
  cansparkmax
      .def(py::init<int, rev::CANSparkMaxLowLevel::MotorType>(), py::arg("deviceID"), py::arg("type"), release_gil())
      .def("set", &rev::CANSparkMax::Set, py::arg("speed"), release_gil())
      .def("get", &rev::CANSparkMax::Get, release_gil())
      .def("setInverted", &rev::CANSparkMax::SetInverted, py::arg("isInverted"), release_gil())
      .def("getInverted", &rev::CANSparkMax::GetInverted, release_gil())
      .def("disable", &rev::CANSparkMax::Disable, release_gil())
      .def("stopMotor", &rev::CANSparkMax::StopMotor, release_gil())
      .def("pidWrite", &rev::CANSparkMax::PIDWrite, py::arg("output"), release_gil())
      .def("getEncoder", &rev::CANSparkMax::GetEncoder, release_gil())
      .def("getPIDController", &rev::CANSparkMax::GetPIDController, release_gil())
      .def("getForwardLimitSwitch", &rev::CANSparkMax::GetForwardLimitSwitch, py::arg("polarity"), release_gil())
      .def("getReverseLimitSwitch", &rev::CANSparkMax::GetReverseLimitSwitch, py::arg("polarity"), release_gil())
      .def("setSmartCurrentLimit", py::overload_cast<unsigned int, unsigned int, unsigned int>(&rev::CANSparkMax::SetSmartCurrentLimit), py::arg("stallLimit"), py::arg("freeLimit")=0, py::arg("limitRPM")=20000, release_gil())
      .def("setSecondaryCurrentLimit", &rev::CANSparkMax::SetSecondaryCurrentLimit, py::arg("limit"), py::arg("limitCycles")=0, release_gil())
      .def("setIdleMode", &rev::CANSparkMax::SetIdleMode, py::arg("mode"), release_gil())
      .def("getIdleMode", &rev::CANSparkMax::GetIdleMode, release_gil())
      .def("enableVoltageCompensation", &rev::CANSparkMax::EnableVoltageCompensation, py::arg("nominalVoltage"), release_gil())
      .def("disableVoltageCompensation", &rev::CANSparkMax::DisableVoltageCompensation, release_gil())
      .def("getVoltageCompensationNominalVoltage", &rev::CANSparkMax::GetVoltageCompensationNominalVoltage, release_gil())
      .def("setOpenLoopRampRate", &rev::CANSparkMax::SetOpenLoopRampRate, py::arg("rate"), release_gil())
      .def("setClosedLoopRampRate", &rev::CANSparkMax::SetClosedLoopRampRate, py::arg("rate"), release_gil())
      .def("getOpenLoopRampRate", &rev::CANSparkMax::GetOpenLoopRampRate, release_gil())
      .def("getClosedLoopRampRate", &rev::CANSparkMax::GetClosedLoopRampRate, release_gil())
      .def("follow", py::overload_cast<const rev::CANSparkMax&, bool>(&rev::CANSparkMax::Follow), py::arg("leader"), py::arg("invert")=false, release_gil())
      .def("isFollower", &rev::CANSparkMax::IsFollower, release_gil())
      .def("getFaults", &rev::CANSparkMax::GetFaults, release_gil())
      .def("getStickyFaults", &rev::CANSparkMax::GetStickyFaults, release_gil())
      .def("getFault", &rev::CANSparkMax::GetFault, py::arg("faultID"), release_gil())
      .def("getStickyFault", &rev::CANSparkMax::GetStickyFault, py::arg("faultID"), release_gil())
      .def("getBusVoltage", &rev::CANSparkMax::GetBusVoltage, release_gil())
      .def("getAppliedOutput", &rev::CANSparkMax::GetAppliedOutput, release_gil())
      .def("getOutputCurrent", &rev::CANSparkMax::GetOutputCurrent, release_gil())
      .def("getMotorTemperature", &rev::CANSparkMax::GetMotorTemperature, release_gil())
      .def("clearFaults", &rev::CANSparkMax::ClearFaults, release_gil())
      .def("burnFlash", &rev::CANSparkMax::BurnFlash, release_gil())
      .def("setCANTimeout", &rev::CANSparkMax::SetCANTimeout, py::arg("milliseconds"), release_gil())
  ;
  candigitalinput
      .def(py::init<rev::CANSparkMax&, rev::CANDigitalInput::LimitSwitch, rev::CANDigitalInput::LimitSwitchPolarity>(), py::arg("device"), py::arg("limitSwitch"), py::arg("polarity"), release_gil())
  ;
  canencoder
      .def(py::init<rev::CANSparkMax&>(), py::arg("device"), release_gil())
  ;
  canpidcontroller
      .def(py::init<rev::CANSparkMax&>(), py::arg("device"), release_gil())
  ;
