#
# This file is autogenerated, do not edit manually. Instead,
# edit gen/data.yml
#

import typing

import hal
from hal_impl.data import hal_data, NotifyDict

from .sim_enums import *


class CANDigitalInput:
    def __init__(self, device: 'CANSparkMax', limitSwitch: LimitSwitch, polarity: LimitSwitchPolarity) -> None:
        """Constructs a CANDigitalInput.

        :param device: The Spark Max to which the limit switch is attached.

        :param limitSwitch: Whether this is forward or reverse limit switch.

        :param polarity: Whether the limit switch is normally open or normally
                   closed.
        """
        assert isinstance(device, CANSparkMax)
        assert isinstance(limitSwitch, LimitSwitch)
        assert isinstance(polarity, LimitSwitchPolarity)
        self._device = device
        self._limitSwitch = limitSwitch
        polarity_param = (
            "limitSwitchFwdPolarity"
            if limitSwitch is LimitSwitch.kForward
            else "limitSwitchRevPolarity"
        )
        polarity = polarity is LimitSwitchPolarity.kNormallyClosed
        device._hal_data[polarity_param] = polarity

    def get(self) -> bool:
        """Get the value from a digital input channel.

        Retrieve the value of a single digital input channel from a motor
        controller. This method will return the state of the limit input
        based on the selected polarity, whether or not it is enabled.
        """
        retval = self._device.getFault(
            FaultID.kHardLimitFwd
            if self._limitSwitch is LimitSwitch.kForward
            else FaultID.kHardLimitRev
        )
        assert isinstance(retval, bool)
        return retval

    def enableLimitSwitch(self, enable: bool) -> CANError:
        """Enables or disables controller shutdown based on limit switch.
        """
        assert isinstance(enable, bool)
        retval = CANError.kOK
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        self._device._hal_data[param] = enable
        return retval

    def isLimitSwitchEnabled(self) -> bool:
        """Returns true if limit switch is enabled.
        """
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        retval = self._device._hal_data[param]
        assert isinstance(retval, bool)
        return retval


class CANEncoder:
    def __init__(self, device: 'CANSparkMax') -> None:
        """Constructs a CANPIDController.

        :param device: The Spark Max to which the encoder is attached.
        """
        assert isinstance(device, CANSparkMax)
        self._device = device
        self._hal_data = device._hal_data

    def getPosition(self) -> float:
        """Get the position of the motor. This returns the native units
        of 'rotations' by default, and can be changed by a scale factor
        using setPositionConversionFactor().

        :returns: Number of rotations of the motor
        """
        retval = self._hal_data["position"]
        if self._inverted:
            retval = -retval
        assert isinstance(retval, float)
        return retval

    def getVelocity(self) -> float:
        """Get the velocity of the motor. This returns the native units
        of 'RPM' by default, and can be changed by a scale factor
        using setVelocityConversionFactor().

        :returns: Number the RPM of the motor
        """
        retval = self._hal_data["velocity"]
        if self._inverted:
            retval = -retval
        assert isinstance(retval, float)
        return retval

    def setPosition(self, position: float) -> CANError:
        """Set the position of the encoder.

        :param position: Number of rotations of the motor

        :returns: CANError Set to CANError.kOk if successful
        """
        assert isinstance(position, (int, float))
        retval = CANError.kOK
        retval = self._device.setEncPosition(position)
        return retval

    def setPositionConversionFactor(self, factor: float) -> CANError:
        """Set the conversion factor for position of the encoder. Multiplied by the
        native output units to give you position

        :param factor: The conversion factor to multiply the native units by

        :returns: CANError Set to CANError.kOk if successful
        """
        assert isinstance(factor, (int, float))
        retval = CANError.kOK
        self._hal_data["positionConversionFactor"] = factor
        return retval

    def setVelocityConversionFactor(self, factor: float) -> CANError:
        """Set the conversion factor for velocity of the encoder. Multiplied by the
        native output units to give you velocity

        :param factor: The conversion factor to multiply the native units by

        :returns: CANError Set to CANError.kOk if successful
        """
        assert isinstance(factor, (int, float))
        retval = CANError.kOK
        self._hal_data["velocityConversionFactor"] = factor
        return retval

    def getPositionConversionFactor(self) -> float:
        """Get the conversion factor for position of the encoder. Multiplied by the
        native output units to give you position

        :returns: The conversion factor for position
        """
        retval = self._hal_data["positionConversionFactor"]
        assert isinstance(retval, float)
        return retval

    def getVelocityConversionFactor(self) -> float:
        """Get the conversion factor for velocity of the encoder. Multiplied by the
        native output units to give you velocity

        :returns: The conversion factor for velocity
        """
        retval = self._hal_data["velocityConversionFactor"]
        assert isinstance(retval, float)
        return retval

    @property
    def _inverted(self) -> bool:
        return self._device._inverted


class CANPIDController:
    def __init__(self, device: 'CANSparkMax') -> None:
        """Constructs a CANPIDController.

        :param device: The Spark Max this object configures.
        """
        assert isinstance(device, CANSparkMax)
        self._device = device
        self._hal_data = device._hal_data

    def setReference(self, value: float, ctrl: ControlType, pidSlot: int = 0, arbFeedforward: float = 0) -> CANError:
        """Set the controller reference value based on the selected control mode.

        :param value: The value to set depending on the control mode. For basic
                      duty cycle control this should be a value between -1 and 1
                      Otherwise: Voltage Control: Voltage (volts) Velocity Control: Velocity
                      (RPM) Position Control: Position (Rotations) Current Control: Current
                      (Amps). The units can be changed for position and velocity by a scale
                      factor using setPositionConversionFactor().

        :param ctrl:  Is the control type

        :param pidSlot: for this command

        :param arbFeedforward: A value from -32.0 to 32.0 which is a voltage
                      applied to the motor after the result of the specified control mode. The
                      units for the parameter is Volts. This value is set after the control
                      mode, but before any current limits or ramp rates.

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(value, (int, float))
        assert isinstance(pidSlot, int)
        assert isinstance(arbFeedforward, (int, float))
        retval = CANError.kOK
        self._device._setpointCommand(value, ctrl, pidSlot, arbFeedforward)
        return retval

    def setP(self, gain: float, slotID: int = 0) -> CANError:
        """Set the Proportional Gain constant of the PIDF controller on the SPARK
        MAX. This uses the Set Parameter API and should be used infrequently. The
        parameter does not presist unless burnFlash() is called.  The recommended
        method to configure this parameter is use to SPARK MAX GUI to tune and
        save parameters.

        :param gain: The proportional gain value, must be positive

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(gain, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["p_%d" % slotID] = float(gain)
        return retval

    def setI(self, gain: float, slotID: int = 0) -> CANError:
        """Set the Integral Gain constant of the PIDF controller on the SPARK MAX.
        This uses the Set Parameter API and should be used infrequently. The
        parameter does not presist unless burnFlash() is called.  The recommended
        method to configure this parameter is use to SPARK MAX GUI to tune and
        save parameters.

        :param gain: The integral gain value, must be positive

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(gain, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["i_%d" % slotID] = float(gain)
        return retval

    def setD(self, gain: float, slotID: int = 0) -> CANError:
        """Set the Derivative Gain constant of the PIDF controller on the SPARK MAX.
        This uses the Set Parameter API and should be used infrequently. The
        parameter does not presist unless burnFlash() is called.  The recommended
        method to configure this parameter is use to SPARK MAX GUI to tune and
        save parameters.

        :param gain: The derivative gain value, must be positive

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(gain, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["d_%d" % slotID] = float(gain)
        return retval

    def setDFilter(self, gain: float, slotID: int = 0) -> CANError:
        """Set the Derivative Filter constant of the PIDF controller on the SPARK
        MAX. This uses the Set Parameter API and should be used infrequently. The
        parameter does not presist unless burnFlash() is called.

        :param gain: The derivative filter value, must be a positive number
              between 0 and 1

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(gain, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["dFilter_%d" % slotID] = float(gain)
        return retval

    def setFF(self, gain: float, slotID: int = 0) -> CANError:
        """Set the Feed-froward Gain constant of the PIDF controller on the SPARK
        MAX. This uses the Set Parameter API and should be used infrequently. The
        parameter does not presist unless burnFlash() is called.  The recommended
        method to configure this parameter is use to SPARK MAX GUI to tune and
        save parameters.

        :param gain: The feed-forward gain value

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(gain, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["f_%d" % slotID] = float(gain)
        return retval

    def setIZone(self, IZone: float, slotID: int = 0) -> CANError:
        """Set the IZone range of the PIDF controller on the SPARK MAX. This value
        specifies the range the |error| must be within for the integral constant
        to take effect.

        This uses the Set Parameter API and should be used infrequently.
        The parameter does not presist unless burnFlash() is called.
        The recommended method to configure this parameter is to use the
        SPARK MAX GUI to tune and save parameters.

        :param gain: The IZone value, must be positive. Set to 0 to disable

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(IZone, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["iZone_%d" % slotID] = float(IZone)
        return retval

    def setOutputRange(self, min: float, max: float, slotID: int = 0) -> CANError:
        """Set the min amd max output for the closed loop mode.

        This uses the Set Parameter API and should be used infrequently.
        The parameter does not presist unless burnFlash() is called.
        The recommended method to configure this parameter is to use the
        SPARK MAX GUI to tune and save parameters.

        :param min: Reverse power minimum to allow the controller to output

        :param max: Forward power maximum to allow the controller to output

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to REV_OK if successful
        """
        assert isinstance(min, (int, float))
        assert isinstance(max, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        if self._inverted:
            min, max = -max, -min
        self._hal_data["outputMin_%d" % slotID] = float(min)
        self._hal_data["outputMax_%d" % slotID] = float(max)
        return retval

    def getP(self, slotID: int = 0) -> float:
        """Get the Proportional Gain constant of the PIDF controller on the SPARK
        MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double P Gain value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["p_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getI(self, slotID: int = 0) -> float:
        """Get the Integral Gain constant of the PIDF controller on the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double I Gain value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["i_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getD(self, slotID: int = 0) -> float:
        """Get the Derivative Gain constant of the PIDF controller on the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double D Gain value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["d_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getDFilter(self, slotID: int = 0) -> float:
        """Get the Derivative Filter constant of the PIDF controller on the SPARK
        MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double D Filter value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["dFilter_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getFF(self, slotID: int = 0) -> float:
        """Get the Feed-forward Gain constant of the PIDF controller on the SPARK
        MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double F Gain value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["f_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getIZone(self, slotID: int = 0) -> float:
        """Get the IZone constant of the PIDF controller on the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double IZone value
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["iZone_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getOutputMin(self, slotID: int = 0) -> float:
        """Get the min output of the PIDF controller on the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double min value
        """
        assert isinstance(slotID, int)
        if self._inverted:
            retval = -self._hal_data["outputMax_%d" % slotID]
        else:
            retval = self._hal_data["outputMin_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getOutputMax(self, slotID: int = 0) -> float:
        """Get the max output of the PIDF controller on the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: double max value
        """
        assert isinstance(slotID, int)
        if self._inverted:
            retval = -self._hal_data["outputMin_%d" % slotID]
        else:
            retval = self._hal_data["outputMax_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def setSmartMotionMaxVelocity(self, maxVel: float, slotID: int = 0) -> CANError:
        """Configure the maximum velocity of the SmartMotion mode. This is the
        velocity that is reached in the middle of the profile and is what the
        motor should spend most of its time at

        :param maxVel: The maxmimum cruise velocity for the motion profile in RPM

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(maxVel, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["smartMotionMaxVelocity_%d" % slotID] = float(maxVel)
        return retval

    def setSmartMotionMaxAccel(self, maxAccel: float, slotID: int = 0) -> CANError:
        """Configure the maximum acceleration of the SmartMotion mode. This is the
        accleration that the motor velocity will increase at until the max
        velocity is reached

        :param maxAccel: The maxmimum acceleration for the motion profile in RPM
                per second

        :param slotID: Is the gain schedule slot, the value is a number
                between 0 and 3. Each slot has its own set of gain values and
                can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(maxAccel, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["smartMotionMaxAccel_%d" % slotID] = float(maxAccel)
        return retval

    def setSmartMotionMinOutputVelocity(self, minVel: float, slotID: int = 0) -> CANError:
        """Configure the mimimum velocity of the SmartMotion mode. Any requested
        velocities below this value will be set to 0.

        :param minVel: The minimum velocity for the motion profile in RPM

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(minVel, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["smartMotionMinVelOutput_%d" % slotID] = float(minVel)
        return retval

    def setSmartMotionAllowedClosedLoopError(self, allowedErr: float, slotID: int = 0) -> CANError:
        """Configure the allowed closed loop error of SmartMotion mode. This value
        is how much deviation from your setpoint is tolerated and is useful in
        preventing oscillation around your setpoint.

        :param allowedErr: The allowed deviation for your setpoint vs actual
                  position in rotations

        :param slotID: Is the gain schedule slot, the value is a number
                  between 0 and 3. Each slot has its own set of gain values and
                  can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(allowedErr, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["smartMotionAllowedClosedLoopError_%d" % slotID] = float(allowedErr)
        return retval

    def setSmartMotionAccelStrategy(self, accelStrategy: AccelStrategy, slotID: int = 0) -> CANError:
        """Coming soon. Configure the acceleration strategy used to control
        acceleration on the motor. The current strategy is trapezoidal motion
        profiling.

        :param accelStrategy: The acceleration strategy to use for the
                     automatically generated motion profile

        :param slotID: Is the gain schedule slot, the value is a number
                     between 0 and 3. Each slot has its own set of gain values and
                     can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(accelStrategy, AccelStrategy)
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["smartMotionAccelStrategy_%d" % slotID] = accelStrategy
        return retval

    def getSmartMotionMaxVelocity(self, slotID: int = 0) -> float:
        """Get the maximum velocity of the SmartMotion mode. This is the velocity
        that is reached in the middle of the profile and is what the motor should
        spend most of its time at

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The maxmimum cruise velocity for the motion profile in RPM
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["smartMotionMaxVelocity_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getSmartMotionMaxAccel(self, slotID: int = 0) -> float:
        """Get the maximum acceleration of the SmartMotion mode. This is the
        accleration that the motor velocity will increase at until the max
        velocity is reached

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The maxmimum acceleration for the motion profile in RPM per
                  second
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["smartMotionMaxAccel_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getSmartMotionMinOutputVelocity(self, slotID: int = 0) -> float:
        """Get the mimimum velocity of the SmartMotion mode. Any requested
        velocities below this value will be set to 0.

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The minimum velocity for the motion profile in RPM
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["smartMotionMinVelOutput_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getSmartMotionAllowedClosedLoopError(self, slotID: int = 0) -> float:
        """Get the allowed closed loop error of SmartMotion mode. This value is how
        much deviation from your setpoint is tolerated and is useful in
        preventing oscillation around your setpoint.

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The allowed deviation for your setpoint vs actual position in
                  rotations
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["smartMotionAllowedClosedLoopError_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def getSmartMotionAccelStrategy(self, slotID: int = 0) -> AccelStrategy:
        """Get the acceleration strategy used to control acceleration on the motor.
        The current strategy is trapezoidal motion profiling.

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The acceleration strategy to use for the automatically generated
                  motion profile
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["smartMotionAccelStrategy_%d" % slotID]
        return retval

    def setIMaxAccum(self, iMaxAccum: float, slotID: int = 0) -> CANError:
        """Configure the maximum I accumulator of the PID controller. This value is
        used to constrain the I accumulator to help manage integral wind-up

        :param iMaxAccum: The max value to contrain the I accumulator to

        :param slotID: Is the gain schedule slot, the value is a number
                 between 0 and 3. Each slot has its own set of gain values and
                 can be changed in each control frame using SetReference().

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(iMaxAccum, (int, float))
        assert isinstance(slotID, int)
        retval = CANError.kOK
        assert 0 <= slotID <= 3
        self._hal_data["iMaxAccum_%d" % slotID] = float(iMaxAccum)
        return retval

    def getIMaxAccum(self, slotID: int = 0) -> float:
        """Get the maximum I accumulator of the PID controller. This value is used
        to constrain the I accumulator to help manage integral wind-up

        :param slotID: Is the gain schedule slot, the value is a number
              between 0 and 3. Each slot has its own set of gain values and
              can be changed in each control frame using SetReference().

        :returns: The max value to contrain the I accumulator to
        """
        assert isinstance(slotID, int)
        assert 0 <= slotID <= 3
        retval = self._hal_data["iMaxAccum_%d" % slotID]
        assert isinstance(retval, float)
        return retval

    def setIAccum(self, iAccum: float) -> CANError:
        """Set the I accumulator of the PID controller. This is useful when wishing
        to force a reset on the I accumulator of the PID controller. You can also
        preset values to see how it will respond to certain I characteristics

        To use this function, the controller must be in a closed loop control
        mode by calling setReference()

        :param iAccum: The value to set the I accumulator to

        :returns: CANError Set to kOK if successful
        """
        assert isinstance(iAccum, (int, float))
        retval = CANError.kOK
        retval = self._device.setIAccum(iAccum)
        return retval

    def getIAccum(self) -> float:
        """Get the I accumulator of the PID controller. This is useful when wishing
        to see what the I accumulator value is to help with PID tuning

        :returns: The value of the I accumulator
        """
        retval = self._hal_data["i_accum"]
        if self._inverted:
            retval = -retval
        assert isinstance(retval, float)
        return retval

    @property
    def _inverted(self) -> bool:
        return self._device._inverted


class CANSparkMaxLowLevel:
    def __init__(self, deviceID: int, type: MotorType) -> None:
        """Create a new SPARK MAX Controller

        :param deviceID: The device ID.

        :param type: The motor type connected to the controller. Brushless
                motors must be connected to their matching color and the
                hall sensor plugged in. Brushed motors must be connected
                to the Red and Black terminals only.
        """
        assert isinstance(deviceID, int)
        assert isinstance(type, MotorType)
        raise TypeError("Cannot instantiate CANSparkMaxLowLevel")

    def getFirmwareVersion(self) -> int:
        """Get the firmware version of the SPARK MAX.

        :returns: uint32_t Firmware version integer. Value is represented as 4
                  bytes, Major.Minor.Build H.Build L

        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.

        """
        raise NotImplementedError("getFirmwareVersion not implemented in simulation (file a bug on github if you need it)")

    def getFirmwareString(self) -> str:
        """Get the firmware version of the SPARK MAX as a string.

        :returns: std::string Human readable firmware version string

        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.

        """
        raise NotImplementedError("getFirmwareString not implemented in simulation (file a bug on github if you need it)")

    def getSerialNumber(self) -> typing.List[int]:
        """Get the unique serial number of the SPARK MAX. Currently not implemented.

        :returns: std::vector<uint8_t> Vector of bytes representig the unique
                  serial number
        """
        retval = []
        return retval

    def getDeviceId(self) -> int:
        """Get the configured Device ID of the SPARK MAX.

        :returns: int device ID
        """
        retval = self._deviceID
        assert isinstance(retval, int)
        return retval

    def setMotorType(self, type: MotorType) -> CANError:
        """Set the motor type connected to the SPARK MAX.

        This uses the Set Parameter API and should be used infrequently.
        The parameter does not presist unless burnFlash() is called.
        The recommended method to configure this parameter is to use the
        SPARK MAX GUI to tune and save parameters.

        :param type: The type of motor connected to the controller. Brushless
            motors must be connected to their matching color and the hall sensor
            plugged in. Brushed motors must be connected to the Red and Black
            terminals only.

        :returns: CANError Set to CANError::kOk if successful
        """
        assert isinstance(type, MotorType)
        retval = CANError.kOK
        self._hal_data["motorType"] = type
        return retval

    def getMotorType(self) -> MotorType:
        """Get the motor type setting for the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :returns: MotorType Motor type setting
        """
        retval = self._hal_data["motorType"]
        return retval

    def setPeriodicFramePeriod(self, frame: PeriodicFrame, periodMs: int) -> CANError:
        """Set the rate of transmission for periodic frames from the SPARK MAX

        Each motor controller sends back three status frames with different
        data at set rates. Use this function to change the default rates.

        Defaults:
        Status0 - 10ms
        Status1 - 20ms
        Status2 - 50ms

        This value is not stored in the FLASH after calling burnFlash()
        and is reset on powerup.

        Refer to the SPARK MAX reference manual on details for how and when
        to configure this parameter.

        :param frameID: The frame ID can be one of PeriodicFrame type

        :param perioidMs: The rate the controller sends the frame to the
                 controller.

        :returns: CANError Set to CANError::kOk if successful
        """
        assert isinstance(frame, PeriodicFrame)
        assert isinstance(periodMs, int)
        retval = CANError.kOK
        self._hal_data["frame_period"][frame] = periodMs
        return retval

    def getParameterType(self, parameterID: ConfigParameter) -> ParameterType:
        """

        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.

        """
        assert isinstance(parameterID, ConfigParameter)
        raise NotImplementedError("getParameterType not implemented in simulation (file a bug on github if you need it)")

    @typing.overload
    def setParameter(self, parameterID: ConfigParameter, value: float) -> ParameterStatus:
        ...

    @typing.overload
    def setParameter(self, parameterID: ConfigParameter, value: int) -> ParameterStatus:
        ...

    @typing.overload
    def setParameter(self, parameterID: ConfigParameter, value: int) -> ParameterStatus:
        ...

    @typing.overload
    def setParameter(self, parameterID: ConfigParameter, value: bool) -> ParameterStatus:
        ...

    def setEncPosition(self, value: float) -> CANError:
        assert isinstance(value, (int, float))
        retval = CANError.kOK
        if self._inverted:
            value *= -1
        self._hal_data["position"] = value
        return retval

    def setIAccum(self, value: float) -> CANError:
        assert isinstance(value, (int, float))
        retval = CANError.kOK
        if self._inverted:
            value *= -1
        self._hal_data["i_accum"] = value
        return retval

    def restoreFactoryDefaults(self, persist: bool = False) -> CANError:
        """Restore motor controller parameters to factory default

        :param persist: If true, burn the flash with the factory default
               parameters

        :returns: CANError Set to CANError::kOk if successful
        """
        assert isinstance(persist, bool)
        retval = CANError.kOK
        # config parameters in camel case (see CANSparkMaxLowLevel::ConfigParameter)
        self._hal_data.update({
            "motorType": MotorType.kBrushless,
            "sensorType": SensorType.kHallSensor,
            "ctrlType": ControlType.kDutyCycle,
            "idleMode": IdleMode.kCoast,
            "polePairs": 7,
            "currentChop": 115.0,
            "currentChopCycles": 0,

            "limitSwitchFwdPolarity": False,
            "limitSwitchRevPolarity": False,
            "hardLimitFwdEn": True,
            "hardLimitRevEn": True,

            "openLoopRampRate": 0.0,
            # TODO follower config
            "smartCurrentStallLimit": 80,
            "smartCurrentFreeLimit": 20,
            "smartCurrentConfig": 10000,

            "encoderCountsPerRev": 4096,
            "encoderAverageDepth": 64,
            "encoderSampleDelta": 200,
            "voltageCompMode": 0,
            "compensatedNominalVoltage": 0.0,

            "positionConversionFactor": 1.0,
            "velocityConversionFactor": 1.0,
            "closedLoopRampRate": 0.0,
        })
        for i in range(4):
            self._hal_data.update({
                "p_%d" % i: 0.0,
                "i_%d" % i: 0.0,
                "d_%d" % i: 0.0,
                "f_%d" % i: 0.0,
                "iZone_%d" % i: 0.0,
                "dFilter_%d" % i: 0.0,
                "outputMin_%d" % i: -1.0,
                "outputMax_%d" % i: 1.0,

                # TODO get defaults for Smart Motion
                "smartMotionMaxVelocity_%d" % i: 0.0,
                "smartMotionMaxAccel_%d" % i: 0.0,
                "smartMotionMinVelOutput_%d" % i: 0.0,
                "smartMotionAllowedClosedLoopError_%d" % i: 0.0,
                "smartMotionAccelStrategy_%d" % i: AccelStrategy.kTrapezoidal,

                "iMaxAccum_%d" % i: 0.0,
            })
        return retval

    def setParameter(
        self,
        parameterID: ConfigParameter,
        value: typing.Union[float, int]
    ) -> ParameterStatus:
        """
        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.
        """
        assert isinstance(parameterID, ConfigParameter)
        assert isinstance(value, (float, int))
        raise NotImplementedError("setParameter not implemented in simulation (file a bug on github if you need it)")

    def _setpointCommand(
        self,
        value: float,
        ctrl: ControlType = ControlType.kDutyCycle,
        pidSlot: int = 0,
        arbFeedforward: float = 0.0,
    ) -> None:
        if arbFeedforward > 32.0:
            arbFeedforward = 32.0
        elif arbFeedforward < -32.0:
            arbFeedforward = -32.0
        if self._inverted:
            value = -value
            arbFeedforward = -arbFeedforward
        self._hal_data["value"] = float(value)  # TODO
        self._hal_data["ctrlType"] = ctrl
        self._hal_data["pid_slot"] = pidSlot
        self._hal_data["arb_ff"] = float(arbFeedforward)


class CANSparkMax(CANSparkMaxLowLevel):
    def __init__(self, deviceID: int, type: MotorType) -> None:
        """Create a new SPARK MAX Controller

        :param deviceID: The device ID.

        :param type: The motor type connected to the controller. Brushless
                motors must be connected to their matching color and the
                hall sensor plugged in. Brushed motors must be connected
                to the Red and Black terminals only.
        """
        assert isinstance(deviceID, int)
        assert isinstance(type, MotorType)
        # everything that would be in the low-level constructor
        # do not call super().__init__()
        self._deviceID = deviceID
        self._inverted = False
        self._faults = NotifyDict({})  # type: typing.Dict[FaultID, bool]
        self._hal_data = NotifyDict({
            "type": "sparkmax",  # make the robotpy-ctre sim ui happy
            "can_timeout": 20,
            "frame_period": NotifyDict({
                PeriodicFrame.kStatus0: 10,
                PeriodicFrame.kStatus1: 20,
                PeriodicFrame.kStatus2: 50,
            }),
            "value": 0.0,
            "position": 0.0,
            "velocity": 0.0,
            "pid_slot": 0,
            "arb_ff": 0.0,
            "faults": self._faults,
            "bus_voltage": 12.0,
            "output_current": 0.1,
            "motor_temp": 25.0,  # ~room temperature
            # config parameters in restoreFactoryDefaults
        })
        self.restoreFactoryDefaults()
        self.setMotorType(type)
        hal_data["CAN"]["sparkmax-%d" % deviceID] = self._hal_data
        hal.report(hal.UsageReporting.kResourceType_RevSparkMaxCAN, deviceID)

        # Initialize conversion factors to 1
        self.getEncoder().setPositionConversionFactor(1)
        self.getEncoder().setVelocityConversionFactor(1)
        self.clearFaults()

    def set(self, speed: float) -> None:
        """Common interface for setting the speed of a speed controller.

        :param speed: The speed to set.  Value should be between -1.0 and 1.0.
        """
        assert isinstance(speed, (int, float))
        self._setpointCommand(speed)

    def get(self) -> float:
        """Common interface for getting the current set speed of a speed controller.

        :returns: The current set speed.  Value is between -1.0 and 1.0.
        """
        retval = self._hal_data["value"]
        assert isinstance(retval, float)
        return retval

    def setInverted(self, isInverted: bool) -> None:
        """Common interface for inverting direction of a speed controller.
        This has no effect if the controller is a follower.

        :param isInverted: The state of inversion, true is inverted.
        """
        assert isinstance(isInverted, bool)
        self._inverted = isInverted

    def getInverted(self) -> bool:
        """Common interface for returning the inversion state of a speed controller.

        :returns: isInverted The state of inversion, true is inverted.
        """
        retval = self._inverted
        assert isinstance(retval, bool)
        return retval

    def disable(self) -> None:
        """Common interface for disabling a motor.
        """
        self.set(0)

    def stopMotor(self) -> None:
        """Common interface to stop the motor until Set is called again.
        """
        self.set(0)

    def pidWrite(self, output: float) -> None:
        assert isinstance(output, (int, float))
        self.set(output)

    def getEncoder(self) -> CANEncoder:
        """Returns an object for interfacing with the integrated encoder.
        """
        retval = CANEncoder(self)
        return retval

    def getPIDController(self) -> CANPIDController:
        """Returns an object for interfacing with the integrated PID controller.
        """
        retval = CANPIDController(self)
        return retval

    def getForwardLimitSwitch(self, polarity: LimitSwitchPolarity) -> CANDigitalInput:
        """Returns an object for interfacing with the integrated forward limit
        switch.

        :param polarity: Whether the limit switch is normally open or normally
                closed.
        """
        retval = CANDigitalInput(self, LimitSwitch.kForward, polarity)
        return retval

    def getReverseLimitSwitch(self, polarity: LimitSwitchPolarity) -> CANDigitalInput:
        """Returns an object for interfacing with the integrated reverse limit
        switch.

        :param polarity: Whether the limit switch is normally open or normally
                closed.
        """
        retval = CANDigitalInput(self, LimitSwitch.kReverse, polarity)
        return retval

    def setSmartCurrentLimit(self, stallLimit: int, freeLimit: int = 0, limitRPM: int = 20000) -> CANError:
        """Sets the current limit in Amps.

        The motor controller will reduce the controller voltage output to avoid
        surpassing this limit. This limit is enabled by default and used for
        brushless only. This limit is highly recommended when using the NEO
        brushless motor.

        The NEO Brushless Motor has a low internal resistance, which
        can mean large current spikes that could be enough to cause damage to
        the motor and controller. This current limit provides a smarter
        strategy to deal with high current draws and keep the motor and
        controller operating in a safe region.

        The controller can also limit the current based on the RPM of the motor
        in a linear fashion to help with controllability in closed loop control.
        For a response that is linear the entire RPM range leave limit RPM at 0.

        :param stallLimit: The current limit in Amps at 0 RPM.

        :param freeLimit: The current limit at free speed (5700RPM for NEO).

        :param limitRPM: RPM less than this value will be set to the stallLimit,
                  RPM values greater than limitRPM will scale linearly to freeLimit
        """
        retval = CANError.kOK
        self._hal_data["smartCurrentStallLimit"] = stallLimit
        self._hal_data["smartCurrentFreeLimit"] = freeLimit
        self._hal_data["smartCurrentConfig"] = limitRPM
        return retval

    def setSecondaryCurrentLimit(self, limit: float, limitCycles: int = 0) -> CANError:
        """Sets the secondary current limit in Amps.

        The motor controller will disable the output of the controller briefly
        if the current limit is exceeded to reduce the current. This limit is
        a simplified 'on/off' controller. This limit is enabled by default
        but is set higher than the default Smart Current Limit.

        The time the controller is off after the current limit is reached
        is determined by the parameter limitCycles, which is the number of
        PWM cycles (20kHz). The recommended value is the default of 0 which
        is the minimum time and is part of a PWM cycle from when the over
        current is detected. This allows the controller to regulate the current
        close to the limit value.

        The total time is set by the equation::

          t = (50us - t0) + 50us * limitCycles
          t = total off time after over current
          t0 = time from the start of the PWM cycle until over current is detected

        :param limit: The current limit in Amps.
        :param limitCycles: The number of additional PWM cycles to turn
                            the driver off after overcurrent is detected.

        """
        assert isinstance(limit, (int, float))
        assert isinstance(limitCycles, int)
        retval = CANError.kOK
        self._hal_data["currentChop"] = float(limit)
        self._hal_data["currentChopCycles"] = limitCycles
        return retval

    def setIdleMode(self, mode: IdleMode) -> CANError:
        """Sets the idle mode setting for the SPARK MAX.

        :param mode: Idle mode (coast or brake).
        """
        assert isinstance(mode, IdleMode)
        retval = CANError.kOK
        self._hal_data["idleMode"] = mode
        return retval

    def getIdleMode(self) -> IdleMode:
        """Gets the idle mode setting for the SPARK MAX.

        This uses the Get Parameter API and should be used infrequently. This
        function uses a non-blocking call and will return a cached value if the
        parameter is not returned by the timeout. The timeout can be changed by
        calling SetCANTimeout(int milliseconds)

        :returns: IdleMode Idle mode setting
        """
        retval = self._hal_data["idleMode"]
        return retval

    def enableVoltageCompensation(self, nominalVoltage: float) -> CANError:
        """Sets the voltage compensation setting for all modes on the SPARK MAX and
        enables voltage compensation.

        :param nominalVoltage: Nominal voltage to compensate output to

        :returns: CANError Set to CANError.kOk if successful
        """
        assert isinstance(nominalVoltage, (int, float))
        retval = CANError.kOK
        self._hal_data["compensatedNominalVoltage"] = nominalVoltage
        self._hal_data["voltageCompMode"] = 2
        return retval

    def disableVoltageCompensation(self) -> CANError:
        """Disables the voltage compensation setting for all modes on the SPARK MAX.

        :returns: CANError Set to CANError.kOk if successful
        """
        retval = CANError.kOK
        self._hal_data["voltageCompMode"] = 0
        self._hal_data["compensatedNominalVoltage"] = 0.0
        return retval

    def getVoltageCompensationNominalVoltage(self) -> float:
        """Get the configured voltage compensation nominal voltage value

        :returns: The nominal voltage for voltage compensation mode.
        """
        retval = self._hal_data["compensatedNominalVoltage"]
        assert isinstance(retval, float)
        return retval

    def setOpenLoopRampRate(self, rate: float) -> CANError:
        """Sets the ramp rate for open loop control modes.

        This is the maximum rate at which the motor controller's output
        is allowed to change.

        :param rate: Time in seconds to go from 0 to full throttle.
        """
        assert isinstance(rate, (int, float))
        retval = CANError.kOK
        if rate != 0.0:
            rate = 1 / rate
        else:
            rate = 0.0
        self._hal_data["openLoopRampRate"] = rate
        return retval

    def setClosedLoopRampRate(self, rate: float) -> CANError:
        """Sets the ramp rate for closed loop control modes.

        This is the maximum rate at which the motor controller's output
        is allowed to change.

        :param rate: Time in seconds to go from 0 to full throttle.
        """
        assert isinstance(rate, (int, float))
        retval = CANError.kOK
        if rate != 0.0:
            rate = 1 / rate
        else:
            rate = 0.0
        self._hal_data["closedLoopRampRate"] = rate
        return retval

    def getOpenLoopRampRate(self) -> float:
        """Get the configured open loop ramp rate

        This is the maximum rate at which the motor controller's output
        is allowed to change.

        :returns: rampte rate time in seconds to go from 0 to full throttle.
        """
        retval = self._hal_data["openLoopRampRate"]
        if retval != 0.0:
            retval = 1 / retval
        assert isinstance(retval, float)
        return retval

    def getClosedLoopRampRate(self) -> float:
        """Get the configured closed loop ramp rate

        This is the maximum rate at which the motor controller's output
        is allowed to change.

        :returns: rampte rate time in seconds to go from 0 to full throttle.
        """
        retval = self._hal_data["closedLoopRampRate"]
        if retval != 0.0:
            retval = 1 / retval
        assert isinstance(retval, float)
        return retval

    def follow(self, leader: "CANSparkMax", invert: bool = False) -> CANError:
        """Causes this controller's output to mirror the provided leader.

        Only voltage output is mirrored. Settings changed on the leader do not
        affect the follower.

        :param leader: The motor controller to follow.

        :param invert: Set the follower to output opposite of the leader

        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.

        """
        assert isinstance(leader, CANSparkMax)
        assert isinstance(invert, bool)
        retval = CANError.kOK
        raise NotImplementedError("follow not implemented in simulation (file a bug on github if you need it)")

    def isFollower(self) -> bool:
        """Returns whether the controller is following another controller

        :returns: True if this device is following another controller
                  false otherwise

        .. note:: This function works on a real robot, but has not yet
                  been implemented in simulation mode. See :ref:`api_support`
                  for more details.

        """
        raise NotImplementedError("isFollower not implemented in simulation (file a bug on github if you need it)")

    def getFaults(self) -> int:
        """Returns fault bits.
        """
        retval = 0
        for faultID, value in self._faults.items():
            retval |= value << faultID.value
        assert isinstance(retval, int) and 0 <= retval < 1<<16
        return retval

    def getStickyFaults(self) -> int:
        """Returns sticky fault bits.
        """
        retval = 0
        assert isinstance(retval, int) and 0 <= retval < 1<<16
        return retval

    def getFault(self, faultID: FaultID) -> bool:
        """Returns whether the fault with the given ID occurred.
        """
        assert isinstance(faultID, FaultID)
        retval = self._faults.get(faultID, False)
        assert isinstance(retval, bool)
        return retval

    def getStickyFault(self, faultID: FaultID) -> bool:
        """Returns whether the sticky fault with the given ID occurred.
        """
        assert isinstance(faultID, FaultID)
        retval = False
        assert isinstance(retval, bool)
        return retval

    def getBusVoltage(self) -> float:
        """Returns the voltage fed into the motor controller.
        """
        retval = self._hal_data["bus_voltage"]
        assert isinstance(retval, float)
        return retval

    def getAppliedOutput(self) -> float:
        """Returns motor controller's output duty cycle.
        """
        retval = self._hal_data["value"]
        assert isinstance(retval, float)
        return retval

    def getOutputCurrent(self) -> float:
        """Returns motor controller's output current in Amps.
        """
        retval = self._hal_data["output_current"]
        assert isinstance(retval, float)
        return retval

    def getMotorTemperature(self) -> float:
        """Returns the motor temperature in Celsius.
        """
        retval = self._hal_data["motor_temp"]
        assert isinstance(retval, float)
        return retval

    def clearFaults(self) -> CANError:
        """Clears all non-sticky faults.

        Sticky faults must be cleared by resetting the motor controller.
        """
        retval = CANError.kOK
        faults = self._faults
        faults.clear()
        faults.update({
            FaultID.kHardLimitFwd: False,
            FaultID.kHardLimitRev: False,
        })
        return retval

    def burnFlash(self) -> CANError:
        """Writes all settings to flash.
        """
        retval = CANError.kOK
        
        return retval

    def setCANTimeout(self, milliseconds: int) -> CANError:
        """Sets timeout for sending CAN messages.

        :param milliseconds: The timeout in milliseconds.
        """
        assert isinstance(milliseconds, int)
        retval = CANError.kOK
        self._hal_data["can_timeout"] = milliseconds
        return retval

